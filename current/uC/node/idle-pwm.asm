; ************************************************ 
; **         THIS FILE IS AUTOGENERATED!        ** 
; ** YOU PROBABLY REALLY DON'T WANT TO EDIT IT! ** 
; ************************************************ 
; Source: template_idle-pwm.asm

	radix	hex

	#include "main.h"
	#include "sensorcfg.h"
	#include "protocol.h"
	#include "idletimer.h"
	#include "memoryplacement.h"

	errorlevel  -302  

	CODE

dopwmsensors:
	global dopwmsensors


#ifdef SENSOR_1_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_1_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_1_PORT, SENSOR_1_PIN
;	bcf SENSOR_1_PORT, SENSOR_1_PIN
;retnow1:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_1_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade1	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_1_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately1

dofade1:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_1_ROLLING_TIMER_HIGH, f
	goto dontdofade1

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_1_PWM_SPEED
	movwf SENSOR_1_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_1_PWM_VOLUME
	subwf SENSOR_1_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade1		; Target = volume

	btfss STATUS, C
	goto fadedown1

	incf SENSOR_1_PWM_VOLUME, f		; fade up!
	goto dontdofade1
fadedown1:
	decf SENSOR_1_PWM_VOLUME, f		; fade down!
	goto dontdofade1
updateImmediately1:
	movfw SENSOR_1_PWM_TARGET
	movwf SENSOR_1_PWM_VOLUME

dontdofade1:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_1_ROLLING_TIMER_LOW
	subwf SENSOR_1_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit1

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_1_PORT, SENSOR_1_PIN
	goto retnow1

overlimit1:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_1_PORT, SENSOR_1_PIN

retnow1:

	#endif
#endif


#ifdef SENSOR_2_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_2_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_2_PORT, SENSOR_2_PIN
;	bcf SENSOR_2_PORT, SENSOR_2_PIN
;retnow2:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_2_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade2	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_2_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately2

dofade2:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_2_ROLLING_TIMER_HIGH, f
	goto dontdofade2

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_2_PWM_SPEED
	movwf SENSOR_2_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_2_PWM_VOLUME
	subwf SENSOR_2_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade2		; Target = volume

	btfss STATUS, C
	goto fadedown2

	incf SENSOR_2_PWM_VOLUME, f		; fade up!
	goto dontdofade2
fadedown2:
	decf SENSOR_2_PWM_VOLUME, f		; fade down!
	goto dontdofade2
updateImmediately2:
	movfw SENSOR_2_PWM_TARGET
	movwf SENSOR_2_PWM_VOLUME

dontdofade2:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_2_ROLLING_TIMER_LOW
	subwf SENSOR_2_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit2

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_2_PORT, SENSOR_2_PIN
	goto retnow2

overlimit2:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_2_PORT, SENSOR_2_PIN

retnow2:

	#endif
#endif


#ifdef SENSOR_3_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_3_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_3_PORT, SENSOR_3_PIN
;	bcf SENSOR_3_PORT, SENSOR_3_PIN
;retnow3:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_3_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade3	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_3_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately3

dofade3:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_3_ROLLING_TIMER_HIGH, f
	goto dontdofade3

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_3_PWM_SPEED
	movwf SENSOR_3_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_3_PWM_VOLUME
	subwf SENSOR_3_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade3		; Target = volume

	btfss STATUS, C
	goto fadedown3

	incf SENSOR_3_PWM_VOLUME, f		; fade up!
	goto dontdofade3
fadedown3:
	decf SENSOR_3_PWM_VOLUME, f		; fade down!
	goto dontdofade3
updateImmediately3:
	movfw SENSOR_3_PWM_TARGET
	movwf SENSOR_3_PWM_VOLUME

dontdofade3:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_3_ROLLING_TIMER_LOW
	subwf SENSOR_3_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit3

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_3_PORT, SENSOR_3_PIN
	goto retnow3

overlimit3:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_3_PORT, SENSOR_3_PIN

retnow3:

	#endif
#endif


#ifdef SENSOR_4_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_4_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_4_PORT, SENSOR_4_PIN
;	bcf SENSOR_4_PORT, SENSOR_4_PIN
;retnow4:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_4_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade4	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_4_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately4

dofade4:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_4_ROLLING_TIMER_HIGH, f
	goto dontdofade4

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_4_PWM_SPEED
	movwf SENSOR_4_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_4_PWM_VOLUME
	subwf SENSOR_4_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade4		; Target = volume

	btfss STATUS, C
	goto fadedown4

	incf SENSOR_4_PWM_VOLUME, f		; fade up!
	goto dontdofade4
fadedown4:
	decf SENSOR_4_PWM_VOLUME, f		; fade down!
	goto dontdofade4
updateImmediately4:
	movfw SENSOR_4_PWM_TARGET
	movwf SENSOR_4_PWM_VOLUME

dontdofade4:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_4_ROLLING_TIMER_LOW
	subwf SENSOR_4_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit4

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_4_PORT, SENSOR_4_PIN
	goto retnow4

overlimit4:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_4_PORT, SENSOR_4_PIN

retnow4:

	#endif
#endif


#ifdef SENSOR_5_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_5_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_5_PORT, SENSOR_5_PIN
;	bcf SENSOR_5_PORT, SENSOR_5_PIN
;retnow5:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_5_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade5	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_5_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately5

dofade5:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_5_ROLLING_TIMER_HIGH, f
	goto dontdofade5

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_5_PWM_SPEED
	movwf SENSOR_5_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_5_PWM_VOLUME
	subwf SENSOR_5_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade5		; Target = volume

	btfss STATUS, C
	goto fadedown5

	incf SENSOR_5_PWM_VOLUME, f		; fade up!
	goto dontdofade5
fadedown5:
	decf SENSOR_5_PWM_VOLUME, f		; fade down!
	goto dontdofade5
updateImmediately5:
	movfw SENSOR_5_PWM_TARGET
	movwf SENSOR_5_PWM_VOLUME

dontdofade5:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_5_ROLLING_TIMER_LOW
	subwf SENSOR_5_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit5

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_5_PORT, SENSOR_5_PIN
	goto retnow5

overlimit5:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_5_PORT, SENSOR_5_PIN

retnow5:

	#endif
#endif


#ifdef SENSOR_6_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_6_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_6_PORT, SENSOR_6_PIN
;	bcf SENSOR_6_PORT, SENSOR_6_PIN
;retnow6:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_6_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade6	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_6_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately6

dofade6:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_6_ROLLING_TIMER_HIGH, f
	goto dontdofade6

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_6_PWM_SPEED
	movwf SENSOR_6_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_6_PWM_VOLUME
	subwf SENSOR_6_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade6		; Target = volume

	btfss STATUS, C
	goto fadedown6

	incf SENSOR_6_PWM_VOLUME, f		; fade up!
	goto dontdofade6
fadedown6:
	decf SENSOR_6_PWM_VOLUME, f		; fade down!
	goto dontdofade6
updateImmediately6:
	movfw SENSOR_6_PWM_TARGET
	movwf SENSOR_6_PWM_VOLUME

dontdofade6:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_6_ROLLING_TIMER_LOW
	subwf SENSOR_6_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit6

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_6_PORT, SENSOR_6_PIN
	goto retnow6

overlimit6:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_6_PORT, SENSOR_6_PIN

retnow6:

	#endif
#endif


#ifdef SENSOR_7_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_7_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_7_PORT, SENSOR_7_PIN
;	bcf SENSOR_7_PORT, SENSOR_7_PIN
;retnow7:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_7_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade7	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_7_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately7

dofade7:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_7_ROLLING_TIMER_HIGH, f
	goto dontdofade7

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_7_PWM_SPEED
	movwf SENSOR_7_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_7_PWM_VOLUME
	subwf SENSOR_7_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade7		; Target = volume

	btfss STATUS, C
	goto fadedown7

	incf SENSOR_7_PWM_VOLUME, f		; fade up!
	goto dontdofade7
fadedown7:
	decf SENSOR_7_PWM_VOLUME, f		; fade down!
	goto dontdofade7
updateImmediately7:
	movfw SENSOR_7_PWM_TARGET
	movwf SENSOR_7_PWM_VOLUME

dontdofade7:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_7_ROLLING_TIMER_LOW
	subwf SENSOR_7_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit7

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_7_PORT, SENSOR_7_PIN
	goto retnow7

overlimit7:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_7_PORT, SENSOR_7_PIN

retnow7:

	#endif
#endif


#ifdef SENSOR_8_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_8_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_8_PORT, SENSOR_8_PIN
;	bcf SENSOR_8_PORT, SENSOR_8_PIN
;retnow8:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_8_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade8	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_8_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately8

dofade8:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_8_ROLLING_TIMER_HIGH, f
	goto dontdofade8

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_8_PWM_SPEED
	movwf SENSOR_8_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_8_PWM_VOLUME
	subwf SENSOR_8_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade8		; Target = volume

	btfss STATUS, C
	goto fadedown8

	incf SENSOR_8_PWM_VOLUME, f		; fade up!
	goto dontdofade8
fadedown8:
	decf SENSOR_8_PWM_VOLUME, f		; fade down!
	goto dontdofade8
updateImmediately8:
	movfw SENSOR_8_PWM_TARGET
	movwf SENSOR_8_PWM_VOLUME

dontdofade8:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_8_ROLLING_TIMER_LOW
	subwf SENSOR_8_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit8

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_8_PORT, SENSOR_8_PIN
	goto retnow8

overlimit8:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_8_PORT, SENSOR_8_PIN

retnow8:

	#endif
#endif


#ifdef SENSOR_9_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_9_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_9_PORT, SENSOR_9_PIN
;	bcf SENSOR_9_PORT, SENSOR_9_PIN
;retnow9:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_9_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade9	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_9_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately9

dofade9:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_9_ROLLING_TIMER_HIGH, f
	goto dontdofade9

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_9_PWM_SPEED
	movwf SENSOR_9_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_9_PWM_VOLUME
	subwf SENSOR_9_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade9		; Target = volume

	btfss STATUS, C
	goto fadedown9

	incf SENSOR_9_PWM_VOLUME, f		; fade up!
	goto dontdofade9
fadedown9:
	decf SENSOR_9_PWM_VOLUME, f		; fade down!
	goto dontdofade9
updateImmediately9:
	movfw SENSOR_9_PWM_TARGET
	movwf SENSOR_9_PWM_VOLUME

dontdofade9:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_9_ROLLING_TIMER_LOW
	subwf SENSOR_9_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit9

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_9_PORT, SENSOR_9_PIN
	goto retnow9

overlimit9:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_9_PORT, SENSOR_9_PIN

retnow9:

	#endif
#endif


#ifdef SENSOR_10_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_10_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_10_PORT, SENSOR_10_PIN
;	bcf SENSOR_10_PORT, SENSOR_10_PIN
;retnow10:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_10_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade10	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_10_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately10

dofade10:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_10_ROLLING_TIMER_HIGH, f
	goto dontdofade10

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_10_PWM_SPEED
	movwf SENSOR_10_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_10_PWM_VOLUME
	subwf SENSOR_10_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade10		; Target = volume

	btfss STATUS, C
	goto fadedown10

	incf SENSOR_10_PWM_VOLUME, f		; fade up!
	goto dontdofade10
fadedown10:
	decf SENSOR_10_PWM_VOLUME, f		; fade down!
	goto dontdofade10
updateImmediately10:
	movfw SENSOR_10_PWM_TARGET
	movwf SENSOR_10_PWM_VOLUME

dontdofade10:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_10_ROLLING_TIMER_LOW
	subwf SENSOR_10_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit10

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_10_PORT, SENSOR_10_PIN
	goto retnow10

overlimit10:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_10_PORT, SENSOR_10_PIN

retnow10:

	#endif
#endif


#ifdef SENSOR_11_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_11_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_11_PORT, SENSOR_11_PIN
;	bcf SENSOR_11_PORT, SENSOR_11_PIN
;retnow11:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_11_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade11	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_11_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately11

dofade11:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_11_ROLLING_TIMER_HIGH, f
	goto dontdofade11

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_11_PWM_SPEED
	movwf SENSOR_11_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_11_PWM_VOLUME
	subwf SENSOR_11_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade11		; Target = volume

	btfss STATUS, C
	goto fadedown11

	incf SENSOR_11_PWM_VOLUME, f		; fade up!
	goto dontdofade11
fadedown11:
	decf SENSOR_11_PWM_VOLUME, f		; fade down!
	goto dontdofade11
updateImmediately11:
	movfw SENSOR_11_PWM_TARGET
	movwf SENSOR_11_PWM_VOLUME

dontdofade11:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_11_ROLLING_TIMER_LOW
	subwf SENSOR_11_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit11

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_11_PORT, SENSOR_11_PIN
	goto retnow11

overlimit11:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_11_PORT, SENSOR_11_PIN

retnow11:

	#endif
#endif


#ifdef SENSOR_12_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_12_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_12_PORT, SENSOR_12_PIN
;	bcf SENSOR_12_PORT, SENSOR_12_PIN
;retnow12:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_12_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade12	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_12_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately12

dofade12:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_12_ROLLING_TIMER_HIGH, f
	goto dontdofade12

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_12_PWM_SPEED
	movwf SENSOR_12_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_12_PWM_VOLUME
	subwf SENSOR_12_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade12		; Target = volume

	btfss STATUS, C
	goto fadedown12

	incf SENSOR_12_PWM_VOLUME, f		; fade up!
	goto dontdofade12
fadedown12:
	decf SENSOR_12_PWM_VOLUME, f		; fade down!
	goto dontdofade12
updateImmediately12:
	movfw SENSOR_12_PWM_TARGET
	movwf SENSOR_12_PWM_VOLUME

dontdofade12:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_12_ROLLING_TIMER_LOW
	subwf SENSOR_12_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit12

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_12_PORT, SENSOR_12_PIN
	goto retnow12

overlimit12:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_12_PORT, SENSOR_12_PIN

retnow12:

	#endif
#endif


#ifdef SENSOR_13_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_13_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_13_PORT, SENSOR_13_PIN
;	bcf SENSOR_13_PORT, SENSOR_13_PIN
;retnow13:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_13_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade13	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_13_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately13

dofade13:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_13_ROLLING_TIMER_HIGH, f
	goto dontdofade13

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_13_PWM_SPEED
	movwf SENSOR_13_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_13_PWM_VOLUME
	subwf SENSOR_13_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade13		; Target = volume

	btfss STATUS, C
	goto fadedown13

	incf SENSOR_13_PWM_VOLUME, f		; fade up!
	goto dontdofade13
fadedown13:
	decf SENSOR_13_PWM_VOLUME, f		; fade down!
	goto dontdofade13
updateImmediately13:
	movfw SENSOR_13_PWM_TARGET
	movwf SENSOR_13_PWM_VOLUME

dontdofade13:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_13_ROLLING_TIMER_LOW
	subwf SENSOR_13_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit13

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_13_PORT, SENSOR_13_PIN
	goto retnow13

overlimit13:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_13_PORT, SENSOR_13_PIN

retnow13:

	#endif
#endif


#ifdef SENSOR_14_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_14_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_14_PORT, SENSOR_14_PIN
;	bcf SENSOR_14_PORT, SENSOR_14_PIN
;retnow14:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_14_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade14	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_14_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately14

dofade14:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_14_ROLLING_TIMER_HIGH, f
	goto dontdofade14

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_14_PWM_SPEED
	movwf SENSOR_14_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_14_PWM_VOLUME
	subwf SENSOR_14_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade14		; Target = volume

	btfss STATUS, C
	goto fadedown14

	incf SENSOR_14_PWM_VOLUME, f		; fade up!
	goto dontdofade14
fadedown14:
	decf SENSOR_14_PWM_VOLUME, f		; fade down!
	goto dontdofade14
updateImmediately14:
	movfw SENSOR_14_PWM_TARGET
	movwf SENSOR_14_PWM_VOLUME

dontdofade14:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_14_ROLLING_TIMER_LOW
	subwf SENSOR_14_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit14

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_14_PORT, SENSOR_14_PIN
	goto retnow14

overlimit14:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_14_PORT, SENSOR_14_PIN

retnow14:

	#endif
#endif


#ifdef SENSOR_15_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_15_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_15_PORT, SENSOR_15_PIN
;	bcf SENSOR_15_PORT, SENSOR_15_PIN
;retnow15:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_15_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade15	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_15_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately15

dofade15:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_15_ROLLING_TIMER_HIGH, f
	goto dontdofade15

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_15_PWM_SPEED
	movwf SENSOR_15_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_15_PWM_VOLUME
	subwf SENSOR_15_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade15		; Target = volume

	btfss STATUS, C
	goto fadedown15

	incf SENSOR_15_PWM_VOLUME, f		; fade up!
	goto dontdofade15
fadedown15:
	decf SENSOR_15_PWM_VOLUME, f		; fade down!
	goto dontdofade15
updateImmediately15:
	movfw SENSOR_15_PWM_TARGET
	movwf SENSOR_15_PWM_VOLUME

dontdofade15:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_15_ROLLING_TIMER_LOW
	subwf SENSOR_15_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit15

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_15_PORT, SENSOR_15_PIN
	goto retnow15

overlimit15:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_15_PORT, SENSOR_15_PIN

retnow15:

	#endif
#endif


#ifdef SENSOR_16_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_16_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_16_PORT, SENSOR_16_PIN
;	bcf SENSOR_16_PORT, SENSOR_16_PIN
;retnow16:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_16_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade16	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_16_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately16

dofade16:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_16_ROLLING_TIMER_HIGH, f
	goto dontdofade16

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_16_PWM_SPEED
	movwf SENSOR_16_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_16_PWM_VOLUME
	subwf SENSOR_16_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade16		; Target = volume

	btfss STATUS, C
	goto fadedown16

	incf SENSOR_16_PWM_VOLUME, f		; fade up!
	goto dontdofade16
fadedown16:
	decf SENSOR_16_PWM_VOLUME, f		; fade down!
	goto dontdofade16
updateImmediately16:
	movfw SENSOR_16_PWM_TARGET
	movwf SENSOR_16_PWM_VOLUME

dontdofade16:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_16_ROLLING_TIMER_LOW
	subwf SENSOR_16_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit16

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_16_PORT, SENSOR_16_PIN
	goto retnow16

overlimit16:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_16_PORT, SENSOR_16_PIN

retnow16:

	#endif
#endif


#ifdef SENSOR_17_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_17_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_17_PORT, SENSOR_17_PIN
;	bcf SENSOR_17_PORT, SENSOR_17_PIN
;retnow17:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_17_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade17	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_17_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately17

dofade17:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_17_ROLLING_TIMER_HIGH, f
	goto dontdofade17

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_17_PWM_SPEED
	movwf SENSOR_17_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_17_PWM_VOLUME
	subwf SENSOR_17_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade17		; Target = volume

	btfss STATUS, C
	goto fadedown17

	incf SENSOR_17_PWM_VOLUME, f		; fade up!
	goto dontdofade17
fadedown17:
	decf SENSOR_17_PWM_VOLUME, f		; fade down!
	goto dontdofade17
updateImmediately17:
	movfw SENSOR_17_PWM_TARGET
	movwf SENSOR_17_PWM_VOLUME

dontdofade17:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_17_ROLLING_TIMER_LOW
	subwf SENSOR_17_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit17

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_17_PORT, SENSOR_17_PIN
	goto retnow17

overlimit17:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_17_PORT, SENSOR_17_PIN

retnow17:

	#endif
#endif


#ifdef SENSOR_18_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_18_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_18_PORT, SENSOR_18_PIN
;	bcf SENSOR_18_PORT, SENSOR_18_PIN
;retnow18:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_18_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade18	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_18_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately18

dofade18:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_18_ROLLING_TIMER_HIGH, f
	goto dontdofade18

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_18_PWM_SPEED
	movwf SENSOR_18_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_18_PWM_VOLUME
	subwf SENSOR_18_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade18		; Target = volume

	btfss STATUS, C
	goto fadedown18

	incf SENSOR_18_PWM_VOLUME, f		; fade up!
	goto dontdofade18
fadedown18:
	decf SENSOR_18_PWM_VOLUME, f		; fade down!
	goto dontdofade18
updateImmediately18:
	movfw SENSOR_18_PWM_TARGET
	movwf SENSOR_18_PWM_VOLUME

dontdofade18:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_18_ROLLING_TIMER_LOW
	subwf SENSOR_18_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit18

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_18_PORT, SENSOR_18_PIN
	goto retnow18

overlimit18:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_18_PORT, SENSOR_18_PIN

retnow18:

	#endif
#endif


#ifdef SENSOR_19_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_19_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_19_PORT, SENSOR_19_PIN
;	bcf SENSOR_19_PORT, SENSOR_19_PIN
;retnow19:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_19_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade19	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_19_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately19

dofade19:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_19_ROLLING_TIMER_HIGH, f
	goto dontdofade19

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_19_PWM_SPEED
	movwf SENSOR_19_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_19_PWM_VOLUME
	subwf SENSOR_19_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade19		; Target = volume

	btfss STATUS, C
	goto fadedown19

	incf SENSOR_19_PWM_VOLUME, f		; fade up!
	goto dontdofade19
fadedown19:
	decf SENSOR_19_PWM_VOLUME, f		; fade down!
	goto dontdofade19
updateImmediately19:
	movfw SENSOR_19_PWM_TARGET
	movwf SENSOR_19_PWM_VOLUME

dontdofade19:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_19_ROLLING_TIMER_LOW
	subwf SENSOR_19_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit19

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_19_PORT, SENSOR_19_PIN
	goto retnow19

overlimit19:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_19_PORT, SENSOR_19_PIN

retnow19:

	#endif
#endif


#ifdef SENSOR_20_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_20_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_20_PORT, SENSOR_20_PIN
;	bcf SENSOR_20_PORT, SENSOR_20_PIN
;retnow20:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_20_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade20	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_20_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately20

dofade20:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_20_ROLLING_TIMER_HIGH, f
	goto dontdofade20

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_20_PWM_SPEED
	movwf SENSOR_20_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_20_PWM_VOLUME
	subwf SENSOR_20_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade20		; Target = volume

	btfss STATUS, C
	goto fadedown20

	incf SENSOR_20_PWM_VOLUME, f		; fade up!
	goto dontdofade20
fadedown20:
	decf SENSOR_20_PWM_VOLUME, f		; fade down!
	goto dontdofade20
updateImmediately20:
	movfw SENSOR_20_PWM_TARGET
	movwf SENSOR_20_PWM_VOLUME

dontdofade20:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_20_ROLLING_TIMER_LOW
	subwf SENSOR_20_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit20

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_20_PORT, SENSOR_20_PIN
	goto retnow20

overlimit20:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_20_PORT, SENSOR_20_PIN

retnow20:

	#endif
#endif


#ifdef SENSOR_21_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_21_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_21_PORT, SENSOR_21_PIN
;	bcf SENSOR_21_PORT, SENSOR_21_PIN
;retnow21:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_21_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade21	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_21_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately21

dofade21:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_21_ROLLING_TIMER_HIGH, f
	goto dontdofade21

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_21_PWM_SPEED
	movwf SENSOR_21_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_21_PWM_VOLUME
	subwf SENSOR_21_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade21		; Target = volume

	btfss STATUS, C
	goto fadedown21

	incf SENSOR_21_PWM_VOLUME, f		; fade up!
	goto dontdofade21
fadedown21:
	decf SENSOR_21_PWM_VOLUME, f		; fade down!
	goto dontdofade21
updateImmediately21:
	movfw SENSOR_21_PWM_TARGET
	movwf SENSOR_21_PWM_VOLUME

dontdofade21:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_21_ROLLING_TIMER_LOW
	subwf SENSOR_21_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit21

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_21_PORT, SENSOR_21_PIN
	goto retnow21

overlimit21:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_21_PORT, SENSOR_21_PIN

retnow21:

	#endif
#endif


#ifdef SENSOR_22_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_22_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_22_PORT, SENSOR_22_PIN
;	bcf SENSOR_22_PORT, SENSOR_22_PIN
;retnow22:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_22_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade22	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_22_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately22

dofade22:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_22_ROLLING_TIMER_HIGH, f
	goto dontdofade22

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_22_PWM_SPEED
	movwf SENSOR_22_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_22_PWM_VOLUME
	subwf SENSOR_22_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade22		; Target = volume

	btfss STATUS, C
	goto fadedown22

	incf SENSOR_22_PWM_VOLUME, f		; fade up!
	goto dontdofade22
fadedown22:
	decf SENSOR_22_PWM_VOLUME, f		; fade down!
	goto dontdofade22
updateImmediately22:
	movfw SENSOR_22_PWM_TARGET
	movwf SENSOR_22_PWM_VOLUME

dontdofade22:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_22_ROLLING_TIMER_LOW
	subwf SENSOR_22_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit22

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_22_PORT, SENSOR_22_PIN
	goto retnow22

overlimit22:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_22_PORT, SENSOR_22_PIN

retnow22:

	#endif
#endif


#ifdef SENSOR_23_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_23_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_23_PORT, SENSOR_23_PIN
;	bcf SENSOR_23_PORT, SENSOR_23_PIN
;retnow23:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_23_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade23	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_23_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately23

dofade23:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_23_ROLLING_TIMER_HIGH, f
	goto dontdofade23

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_23_PWM_SPEED
	movwf SENSOR_23_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_23_PWM_VOLUME
	subwf SENSOR_23_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade23		; Target = volume

	btfss STATUS, C
	goto fadedown23

	incf SENSOR_23_PWM_VOLUME, f		; fade up!
	goto dontdofade23
fadedown23:
	decf SENSOR_23_PWM_VOLUME, f		; fade down!
	goto dontdofade23
updateImmediately23:
	movfw SENSOR_23_PWM_TARGET
	movwf SENSOR_23_PWM_VOLUME

dontdofade23:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_23_ROLLING_TIMER_LOW
	subwf SENSOR_23_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit23

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_23_PORT, SENSOR_23_PIN
	goto retnow23

overlimit23:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_23_PORT, SENSOR_23_PIN

retnow23:

	#endif
#endif


#ifdef SENSOR_24_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_24_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_24_PORT, SENSOR_24_PIN
;	bcf SENSOR_24_PORT, SENSOR_24_PIN
;retnow24:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_24_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade24	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_24_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately24

dofade24:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_24_ROLLING_TIMER_HIGH, f
	goto dontdofade24

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_24_PWM_SPEED
	movwf SENSOR_24_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_24_PWM_VOLUME
	subwf SENSOR_24_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade24		; Target = volume

	btfss STATUS, C
	goto fadedown24

	incf SENSOR_24_PWM_VOLUME, f		; fade up!
	goto dontdofade24
fadedown24:
	decf SENSOR_24_PWM_VOLUME, f		; fade down!
	goto dontdofade24
updateImmediately24:
	movfw SENSOR_24_PWM_TARGET
	movwf SENSOR_24_PWM_VOLUME

dontdofade24:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_24_ROLLING_TIMER_LOW
	subwf SENSOR_24_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit24

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_24_PORT, SENSOR_24_PIN
	goto retnow24

overlimit24:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_24_PORT, SENSOR_24_PIN

retnow24:

	#endif
#endif


#ifdef SENSOR_25_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_25_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_25_PORT, SENSOR_25_PIN
;	bcf SENSOR_25_PORT, SENSOR_25_PIN
;retnow25:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_25_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade25	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_25_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately25

dofade25:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_25_ROLLING_TIMER_HIGH, f
	goto dontdofade25

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_25_PWM_SPEED
	movwf SENSOR_25_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_25_PWM_VOLUME
	subwf SENSOR_25_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade25		; Target = volume

	btfss STATUS, C
	goto fadedown25

	incf SENSOR_25_PWM_VOLUME, f		; fade up!
	goto dontdofade25
fadedown25:
	decf SENSOR_25_PWM_VOLUME, f		; fade down!
	goto dontdofade25
updateImmediately25:
	movfw SENSOR_25_PWM_TARGET
	movwf SENSOR_25_PWM_VOLUME

dontdofade25:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_25_ROLLING_TIMER_LOW
	subwf SENSOR_25_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit25

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_25_PORT, SENSOR_25_PIN
	goto retnow25

overlimit25:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_25_PORT, SENSOR_25_PIN

retnow25:

	#endif
#endif


#ifdef SENSOR_26_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_26_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_26_PORT, SENSOR_26_PIN
;	bcf SENSOR_26_PORT, SENSOR_26_PIN
;retnow26:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_26_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade26	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_26_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately26

dofade26:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_26_ROLLING_TIMER_HIGH, f
	goto dontdofade26

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_26_PWM_SPEED
	movwf SENSOR_26_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_26_PWM_VOLUME
	subwf SENSOR_26_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade26		; Target = volume

	btfss STATUS, C
	goto fadedown26

	incf SENSOR_26_PWM_VOLUME, f		; fade up!
	goto dontdofade26
fadedown26:
	decf SENSOR_26_PWM_VOLUME, f		; fade down!
	goto dontdofade26
updateImmediately26:
	movfw SENSOR_26_PWM_TARGET
	movwf SENSOR_26_PWM_VOLUME

dontdofade26:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_26_ROLLING_TIMER_LOW
	subwf SENSOR_26_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit26

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_26_PORT, SENSOR_26_PIN
	goto retnow26

overlimit26:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_26_PORT, SENSOR_26_PIN

retnow26:

	#endif
#endif


#ifdef SENSOR_27_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_27_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_27_PORT, SENSOR_27_PIN
;	bcf SENSOR_27_PORT, SENSOR_27_PIN
;retnow27:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_27_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade27	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_27_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately27

dofade27:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_27_ROLLING_TIMER_HIGH, f
	goto dontdofade27

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_27_PWM_SPEED
	movwf SENSOR_27_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_27_PWM_VOLUME
	subwf SENSOR_27_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade27		; Target = volume

	btfss STATUS, C
	goto fadedown27

	incf SENSOR_27_PWM_VOLUME, f		; fade up!
	goto dontdofade27
fadedown27:
	decf SENSOR_27_PWM_VOLUME, f		; fade down!
	goto dontdofade27
updateImmediately27:
	movfw SENSOR_27_PWM_TARGET
	movwf SENSOR_27_PWM_VOLUME

dontdofade27:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_27_ROLLING_TIMER_LOW
	subwf SENSOR_27_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit27

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_27_PORT, SENSOR_27_PIN
	goto retnow27

overlimit27:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_27_PORT, SENSOR_27_PIN

retnow27:

	#endif
#endif


#ifdef SENSOR_28_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_28_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_28_PORT, SENSOR_28_PIN
;	bcf SENSOR_28_PORT, SENSOR_28_PIN
;retnow28:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_28_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade28	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_28_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately28

dofade28:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_28_ROLLING_TIMER_HIGH, f
	goto dontdofade28

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_28_PWM_SPEED
	movwf SENSOR_28_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_28_PWM_VOLUME
	subwf SENSOR_28_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade28		; Target = volume

	btfss STATUS, C
	goto fadedown28

	incf SENSOR_28_PWM_VOLUME, f		; fade up!
	goto dontdofade28
fadedown28:
	decf SENSOR_28_PWM_VOLUME, f		; fade down!
	goto dontdofade28
updateImmediately28:
	movfw SENSOR_28_PWM_TARGET
	movwf SENSOR_28_PWM_VOLUME

dontdofade28:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_28_ROLLING_TIMER_LOW
	subwf SENSOR_28_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit28

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_28_PORT, SENSOR_28_PIN
	goto retnow28

overlimit28:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_28_PORT, SENSOR_28_PIN

retnow28:

	#endif
#endif


#ifdef SENSOR_29_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_29_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_29_PORT, SENSOR_29_PIN
;	bcf SENSOR_29_PORT, SENSOR_29_PIN
;retnow29:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_29_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade29	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_29_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately29

dofade29:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_29_ROLLING_TIMER_HIGH, f
	goto dontdofade29

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_29_PWM_SPEED
	movwf SENSOR_29_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_29_PWM_VOLUME
	subwf SENSOR_29_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade29		; Target = volume

	btfss STATUS, C
	goto fadedown29

	incf SENSOR_29_PWM_VOLUME, f		; fade up!
	goto dontdofade29
fadedown29:
	decf SENSOR_29_PWM_VOLUME, f		; fade down!
	goto dontdofade29
updateImmediately29:
	movfw SENSOR_29_PWM_TARGET
	movwf SENSOR_29_PWM_VOLUME

dontdofade29:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_29_ROLLING_TIMER_LOW
	subwf SENSOR_29_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit29

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_29_PORT, SENSOR_29_PIN
	goto retnow29

overlimit29:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_29_PORT, SENSOR_29_PIN

retnow29:

	#endif
#endif


#ifdef SENSOR_30_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_30_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_30_PORT, SENSOR_30_PIN
;	bcf SENSOR_30_PORT, SENSOR_30_PIN
;retnow30:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_30_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade30	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_30_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately30

dofade30:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_30_ROLLING_TIMER_HIGH, f
	goto dontdofade30

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_30_PWM_SPEED
	movwf SENSOR_30_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_30_PWM_VOLUME
	subwf SENSOR_30_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade30		; Target = volume

	btfss STATUS, C
	goto fadedown30

	incf SENSOR_30_PWM_VOLUME, f		; fade up!
	goto dontdofade30
fadedown30:
	decf SENSOR_30_PWM_VOLUME, f		; fade down!
	goto dontdofade30
updateImmediately30:
	movfw SENSOR_30_PWM_TARGET
	movwf SENSOR_30_PWM_VOLUME

dontdofade30:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_30_ROLLING_TIMER_LOW
	subwf SENSOR_30_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit30

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_30_PORT, SENSOR_30_PIN
	goto retnow30

overlimit30:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_30_PORT, SENSOR_30_PIN

retnow30:

	#endif
#endif


#ifdef SENSOR_31_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_31_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_31_PORT, SENSOR_31_PIN
;	bcf SENSOR_31_PORT, SENSOR_31_PIN
;retnow31:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_31_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade31	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_31_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately31

dofade31:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_31_ROLLING_TIMER_HIGH, f
	goto dontdofade31

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_31_PWM_SPEED
	movwf SENSOR_31_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_31_PWM_VOLUME
	subwf SENSOR_31_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade31		; Target = volume

	btfss STATUS, C
	goto fadedown31

	incf SENSOR_31_PWM_VOLUME, f		; fade up!
	goto dontdofade31
fadedown31:
	decf SENSOR_31_PWM_VOLUME, f		; fade down!
	goto dontdofade31
updateImmediately31:
	movfw SENSOR_31_PWM_TARGET
	movwf SENSOR_31_PWM_VOLUME

dontdofade31:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_31_ROLLING_TIMER_LOW
	subwf SENSOR_31_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit31

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_31_PORT, SENSOR_31_PIN
	goto retnow31

overlimit31:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_31_PORT, SENSOR_31_PIN

retnow31:

	#endif
#endif


#ifdef SENSOR_32_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_32_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_32_PORT, SENSOR_32_PIN
;	bcf SENSOR_32_PORT, SENSOR_32_PIN
;retnow32:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_32_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade32	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_32_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately32

dofade32:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_32_ROLLING_TIMER_HIGH, f
	goto dontdofade32

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_32_PWM_SPEED
	movwf SENSOR_32_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_32_PWM_VOLUME
	subwf SENSOR_32_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade32		; Target = volume

	btfss STATUS, C
	goto fadedown32

	incf SENSOR_32_PWM_VOLUME, f		; fade up!
	goto dontdofade32
fadedown32:
	decf SENSOR_32_PWM_VOLUME, f		; fade down!
	goto dontdofade32
updateImmediately32:
	movfw SENSOR_32_PWM_TARGET
	movwf SENSOR_32_PWM_VOLUME

dontdofade32:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_32_ROLLING_TIMER_LOW
	subwf SENSOR_32_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit32

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_32_PORT, SENSOR_32_PIN
	goto retnow32

overlimit32:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_32_PORT, SENSOR_32_PIN

retnow32:

	#endif
#endif


#ifdef SENSOR_33_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_33_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_33_PORT, SENSOR_33_PIN
;	bcf SENSOR_33_PORT, SENSOR_33_PIN
;retnow33:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_33_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade33	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_33_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately33

dofade33:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_33_ROLLING_TIMER_HIGH, f
	goto dontdofade33

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_33_PWM_SPEED
	movwf SENSOR_33_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_33_PWM_VOLUME
	subwf SENSOR_33_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade33		; Target = volume

	btfss STATUS, C
	goto fadedown33

	incf SENSOR_33_PWM_VOLUME, f		; fade up!
	goto dontdofade33
fadedown33:
	decf SENSOR_33_PWM_VOLUME, f		; fade down!
	goto dontdofade33
updateImmediately33:
	movfw SENSOR_33_PWM_TARGET
	movwf SENSOR_33_PWM_VOLUME

dontdofade33:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_33_ROLLING_TIMER_LOW
	subwf SENSOR_33_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit33

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_33_PORT, SENSOR_33_PIN
	goto retnow33

overlimit33:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_33_PORT, SENSOR_33_PIN

retnow33:

	#endif
#endif


#ifdef SENSOR_34_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_34_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_34_PORT, SENSOR_34_PIN
;	bcf SENSOR_34_PORT, SENSOR_34_PIN
;retnow34:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_34_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade34	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_34_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately34

dofade34:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_34_ROLLING_TIMER_HIGH, f
	goto dontdofade34

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_34_PWM_SPEED
	movwf SENSOR_34_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_34_PWM_VOLUME
	subwf SENSOR_34_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade34		; Target = volume

	btfss STATUS, C
	goto fadedown34

	incf SENSOR_34_PWM_VOLUME, f		; fade up!
	goto dontdofade34
fadedown34:
	decf SENSOR_34_PWM_VOLUME, f		; fade down!
	goto dontdofade34
updateImmediately34:
	movfw SENSOR_34_PWM_TARGET
	movwf SENSOR_34_PWM_VOLUME

dontdofade34:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_34_ROLLING_TIMER_LOW
	subwf SENSOR_34_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit34

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_34_PORT, SENSOR_34_PIN
	goto retnow34

overlimit34:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_34_PORT, SENSOR_34_PIN

retnow34:

	#endif
#endif


#ifdef SENSOR_35_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_35_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_35_PORT, SENSOR_35_PIN
;	bcf SENSOR_35_PORT, SENSOR_35_PIN
;retnow35:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_35_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade35	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_35_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately35

dofade35:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_35_ROLLING_TIMER_HIGH, f
	goto dontdofade35

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_35_PWM_SPEED
	movwf SENSOR_35_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_35_PWM_VOLUME
	subwf SENSOR_35_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade35		; Target = volume

	btfss STATUS, C
	goto fadedown35

	incf SENSOR_35_PWM_VOLUME, f		; fade up!
	goto dontdofade35
fadedown35:
	decf SENSOR_35_PWM_VOLUME, f		; fade down!
	goto dontdofade35
updateImmediately35:
	movfw SENSOR_35_PWM_TARGET
	movwf SENSOR_35_PWM_VOLUME

dontdofade35:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_35_ROLLING_TIMER_LOW
	subwf SENSOR_35_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit35

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_35_PORT, SENSOR_35_PIN
	goto retnow35

overlimit35:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_35_PORT, SENSOR_35_PIN

retnow35:

	#endif
#endif


#ifdef SENSOR_36_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_36_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_36_PORT, SENSOR_36_PIN
;	bcf SENSOR_36_PORT, SENSOR_36_PIN
;retnow36:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_36_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade36	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_36_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately36

dofade36:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_36_ROLLING_TIMER_HIGH, f
	goto dontdofade36

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_36_PWM_SPEED
	movwf SENSOR_36_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_36_PWM_VOLUME
	subwf SENSOR_36_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade36		; Target = volume

	btfss STATUS, C
	goto fadedown36

	incf SENSOR_36_PWM_VOLUME, f		; fade up!
	goto dontdofade36
fadedown36:
	decf SENSOR_36_PWM_VOLUME, f		; fade down!
	goto dontdofade36
updateImmediately36:
	movfw SENSOR_36_PWM_TARGET
	movwf SENSOR_36_PWM_VOLUME

dontdofade36:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_36_ROLLING_TIMER_LOW
	subwf SENSOR_36_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit36

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_36_PORT, SENSOR_36_PIN
	goto retnow36

overlimit36:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_36_PORT, SENSOR_36_PIN

retnow36:

	#endif
#endif


#ifdef SENSOR_37_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_37_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_37_PORT, SENSOR_37_PIN
;	bcf SENSOR_37_PORT, SENSOR_37_PIN
;retnow37:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_37_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade37	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_37_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately37

dofade37:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_37_ROLLING_TIMER_HIGH, f
	goto dontdofade37

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_37_PWM_SPEED
	movwf SENSOR_37_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_37_PWM_VOLUME
	subwf SENSOR_37_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade37		; Target = volume

	btfss STATUS, C
	goto fadedown37

	incf SENSOR_37_PWM_VOLUME, f		; fade up!
	goto dontdofade37
fadedown37:
	decf SENSOR_37_PWM_VOLUME, f		; fade down!
	goto dontdofade37
updateImmediately37:
	movfw SENSOR_37_PWM_TARGET
	movwf SENSOR_37_PWM_VOLUME

dontdofade37:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_37_ROLLING_TIMER_LOW
	subwf SENSOR_37_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit37

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_37_PORT, SENSOR_37_PIN
	goto retnow37

overlimit37:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_37_PORT, SENSOR_37_PIN

retnow37:

	#endif
#endif


#ifdef SENSOR_38_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_38_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_38_PORT, SENSOR_38_PIN
;	bcf SENSOR_38_PORT, SENSOR_38_PIN
;retnow38:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_38_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade38	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_38_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately38

dofade38:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_38_ROLLING_TIMER_HIGH, f
	goto dontdofade38

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_38_PWM_SPEED
	movwf SENSOR_38_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_38_PWM_VOLUME
	subwf SENSOR_38_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade38		; Target = volume

	btfss STATUS, C
	goto fadedown38

	incf SENSOR_38_PWM_VOLUME, f		; fade up!
	goto dontdofade38
fadedown38:
	decf SENSOR_38_PWM_VOLUME, f		; fade down!
	goto dontdofade38
updateImmediately38:
	movfw SENSOR_38_PWM_TARGET
	movwf SENSOR_38_PWM_VOLUME

dontdofade38:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_38_ROLLING_TIMER_LOW
	subwf SENSOR_38_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit38

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_38_PORT, SENSOR_38_PIN
	goto retnow38

overlimit38:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_38_PORT, SENSOR_38_PIN

retnow38:

	#endif
#endif


#ifdef SENSOR_39_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_39_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_39_PORT, SENSOR_39_PIN
;	bcf SENSOR_39_PORT, SENSOR_39_PIN
;retnow39:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_39_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade39	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_39_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately39

dofade39:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_39_ROLLING_TIMER_HIGH, f
	goto dontdofade39

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_39_PWM_SPEED
	movwf SENSOR_39_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_39_PWM_VOLUME
	subwf SENSOR_39_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade39		; Target = volume

	btfss STATUS, C
	goto fadedown39

	incf SENSOR_39_PWM_VOLUME, f		; fade up!
	goto dontdofade39
fadedown39:
	decf SENSOR_39_PWM_VOLUME, f		; fade down!
	goto dontdofade39
updateImmediately39:
	movfw SENSOR_39_PWM_TARGET
	movwf SENSOR_39_PWM_VOLUME

dontdofade39:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_39_ROLLING_TIMER_LOW
	subwf SENSOR_39_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit39

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_39_PORT, SENSOR_39_PIN
	goto retnow39

overlimit39:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_39_PORT, SENSOR_39_PIN

retnow39:

	#endif
#endif


#ifdef SENSOR_40_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_40_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_40_PORT, SENSOR_40_PIN
;	bcf SENSOR_40_PORT, SENSOR_40_PIN
;retnow40:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_40_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade40	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_40_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately40

dofade40:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_40_ROLLING_TIMER_HIGH, f
	goto dontdofade40

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_40_PWM_SPEED
	movwf SENSOR_40_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_40_PWM_VOLUME
	subwf SENSOR_40_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade40		; Target = volume

	btfss STATUS, C
	goto fadedown40

	incf SENSOR_40_PWM_VOLUME, f		; fade up!
	goto dontdofade40
fadedown40:
	decf SENSOR_40_PWM_VOLUME, f		; fade down!
	goto dontdofade40
updateImmediately40:
	movfw SENSOR_40_PWM_TARGET
	movwf SENSOR_40_PWM_VOLUME

dontdofade40:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_40_ROLLING_TIMER_LOW
	subwf SENSOR_40_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit40

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_40_PORT, SENSOR_40_PIN
	goto retnow40

overlimit40:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_40_PORT, SENSOR_40_PIN

retnow40:

	#endif
#endif


#ifdef SENSOR_41_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_41_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_41_PORT, SENSOR_41_PIN
;	bcf SENSOR_41_PORT, SENSOR_41_PIN
;retnow41:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_41_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade41	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_41_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately41

dofade41:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_41_ROLLING_TIMER_HIGH, f
	goto dontdofade41

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_41_PWM_SPEED
	movwf SENSOR_41_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_41_PWM_VOLUME
	subwf SENSOR_41_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade41		; Target = volume

	btfss STATUS, C
	goto fadedown41

	incf SENSOR_41_PWM_VOLUME, f		; fade up!
	goto dontdofade41
fadedown41:
	decf SENSOR_41_PWM_VOLUME, f		; fade down!
	goto dontdofade41
updateImmediately41:
	movfw SENSOR_41_PWM_TARGET
	movwf SENSOR_41_PWM_VOLUME

dontdofade41:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_41_ROLLING_TIMER_LOW
	subwf SENSOR_41_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit41

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_41_PORT, SENSOR_41_PIN
	goto retnow41

overlimit41:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_41_PORT, SENSOR_41_PIN

retnow41:

	#endif
#endif


#ifdef SENSOR_42_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_42_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_42_PORT, SENSOR_42_PIN
;	bcf SENSOR_42_PORT, SENSOR_42_PIN
;retnow42:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_42_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade42	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_42_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately42

dofade42:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_42_ROLLING_TIMER_HIGH, f
	goto dontdofade42

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_42_PWM_SPEED
	movwf SENSOR_42_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_42_PWM_VOLUME
	subwf SENSOR_42_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade42		; Target = volume

	btfss STATUS, C
	goto fadedown42

	incf SENSOR_42_PWM_VOLUME, f		; fade up!
	goto dontdofade42
fadedown42:
	decf SENSOR_42_PWM_VOLUME, f		; fade down!
	goto dontdofade42
updateImmediately42:
	movfw SENSOR_42_PWM_TARGET
	movwf SENSOR_42_PWM_VOLUME

dontdofade42:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_42_ROLLING_TIMER_LOW
	subwf SENSOR_42_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit42

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_42_PORT, SENSOR_42_PIN
	goto retnow42

overlimit42:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_42_PORT, SENSOR_42_PIN

retnow42:

	#endif
#endif


#ifdef SENSOR_43_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_43_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_43_PORT, SENSOR_43_PIN
;	bcf SENSOR_43_PORT, SENSOR_43_PIN
;retnow43:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_43_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade43	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_43_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately43

dofade43:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_43_ROLLING_TIMER_HIGH, f
	goto dontdofade43

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_43_PWM_SPEED
	movwf SENSOR_43_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_43_PWM_VOLUME
	subwf SENSOR_43_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade43		; Target = volume

	btfss STATUS, C
	goto fadedown43

	incf SENSOR_43_PWM_VOLUME, f		; fade up!
	goto dontdofade43
fadedown43:
	decf SENSOR_43_PWM_VOLUME, f		; fade down!
	goto dontdofade43
updateImmediately43:
	movfw SENSOR_43_PWM_TARGET
	movwf SENSOR_43_PWM_VOLUME

dontdofade43:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_43_ROLLING_TIMER_LOW
	subwf SENSOR_43_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit43

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_43_PORT, SENSOR_43_PIN
	goto retnow43

overlimit43:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_43_PORT, SENSOR_43_PIN

retnow43:

	#endif
#endif


#ifdef SENSOR_44_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_44_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_44_PORT, SENSOR_44_PIN
;	bcf SENSOR_44_PORT, SENSOR_44_PIN
;retnow44:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_44_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade44	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_44_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately44

dofade44:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_44_ROLLING_TIMER_HIGH, f
	goto dontdofade44

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_44_PWM_SPEED
	movwf SENSOR_44_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_44_PWM_VOLUME
	subwf SENSOR_44_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade44		; Target = volume

	btfss STATUS, C
	goto fadedown44

	incf SENSOR_44_PWM_VOLUME, f		; fade up!
	goto dontdofade44
fadedown44:
	decf SENSOR_44_PWM_VOLUME, f		; fade down!
	goto dontdofade44
updateImmediately44:
	movfw SENSOR_44_PWM_TARGET
	movwf SENSOR_44_PWM_VOLUME

dontdofade44:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_44_ROLLING_TIMER_LOW
	subwf SENSOR_44_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit44

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_44_PORT, SENSOR_44_PIN
	goto retnow44

overlimit44:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_44_PORT, SENSOR_44_PIN

retnow44:

	#endif
#endif


#ifdef SENSOR_45_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_45_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_45_PORT, SENSOR_45_PIN
;	bcf SENSOR_45_PORT, SENSOR_45_PIN
;retnow45:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_45_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade45	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_45_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately45

dofade45:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_45_ROLLING_TIMER_HIGH, f
	goto dontdofade45

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_45_PWM_SPEED
	movwf SENSOR_45_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_45_PWM_VOLUME
	subwf SENSOR_45_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade45		; Target = volume

	btfss STATUS, C
	goto fadedown45

	incf SENSOR_45_PWM_VOLUME, f		; fade up!
	goto dontdofade45
fadedown45:
	decf SENSOR_45_PWM_VOLUME, f		; fade down!
	goto dontdofade45
updateImmediately45:
	movfw SENSOR_45_PWM_TARGET
	movwf SENSOR_45_PWM_VOLUME

dontdofade45:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_45_ROLLING_TIMER_LOW
	subwf SENSOR_45_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit45

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_45_PORT, SENSOR_45_PIN
	goto retnow45

overlimit45:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_45_PORT, SENSOR_45_PIN

retnow45:

	#endif
#endif


#ifdef SENSOR_46_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_46_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_46_PORT, SENSOR_46_PIN
;	bcf SENSOR_46_PORT, SENSOR_46_PIN
;retnow46:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_46_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade46	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_46_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately46

dofade46:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_46_ROLLING_TIMER_HIGH, f
	goto dontdofade46

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_46_PWM_SPEED
	movwf SENSOR_46_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_46_PWM_VOLUME
	subwf SENSOR_46_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade46		; Target = volume

	btfss STATUS, C
	goto fadedown46

	incf SENSOR_46_PWM_VOLUME, f		; fade up!
	goto dontdofade46
fadedown46:
	decf SENSOR_46_PWM_VOLUME, f		; fade down!
	goto dontdofade46
updateImmediately46:
	movfw SENSOR_46_PWM_TARGET
	movwf SENSOR_46_PWM_VOLUME

dontdofade46:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_46_ROLLING_TIMER_LOW
	subwf SENSOR_46_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit46

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_46_PORT, SENSOR_46_PIN
	goto retnow46

overlimit46:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_46_PORT, SENSOR_46_PIN

retnow46:

	#endif
#endif


#ifdef SENSOR_47_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_47_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_47_PORT, SENSOR_47_PIN
;	bcf SENSOR_47_PORT, SENSOR_47_PIN
;retnow47:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_47_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade47	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_47_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately47

dofade47:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_47_ROLLING_TIMER_HIGH, f
	goto dontdofade47

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_47_PWM_SPEED
	movwf SENSOR_47_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_47_PWM_VOLUME
	subwf SENSOR_47_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade47		; Target = volume

	btfss STATUS, C
	goto fadedown47

	incf SENSOR_47_PWM_VOLUME, f		; fade up!
	goto dontdofade47
fadedown47:
	decf SENSOR_47_PWM_VOLUME, f		; fade down!
	goto dontdofade47
updateImmediately47:
	movfw SENSOR_47_PWM_TARGET
	movwf SENSOR_47_PWM_VOLUME

dontdofade47:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_47_ROLLING_TIMER_LOW
	subwf SENSOR_47_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit47

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_47_PORT, SENSOR_47_PIN
	goto retnow47

overlimit47:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_47_PORT, SENSOR_47_PIN

retnow47:

	#endif
#endif


#ifdef SENSOR_48_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_48_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_48_PORT, SENSOR_48_PIN
;	bcf SENSOR_48_PORT, SENSOR_48_PIN
;retnow48:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_48_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade48	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_48_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately48

dofade48:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_48_ROLLING_TIMER_HIGH, f
	goto dontdofade48

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_48_PWM_SPEED
	movwf SENSOR_48_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_48_PWM_VOLUME
	subwf SENSOR_48_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade48		; Target = volume

	btfss STATUS, C
	goto fadedown48

	incf SENSOR_48_PWM_VOLUME, f		; fade up!
	goto dontdofade48
fadedown48:
	decf SENSOR_48_PWM_VOLUME, f		; fade down!
	goto dontdofade48
updateImmediately48:
	movfw SENSOR_48_PWM_TARGET
	movwf SENSOR_48_PWM_VOLUME

dontdofade48:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_48_ROLLING_TIMER_LOW
	subwf SENSOR_48_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit48

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_48_PORT, SENSOR_48_PIN
	goto retnow48

overlimit48:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_48_PORT, SENSOR_48_PIN

retnow48:

	#endif
#endif


#ifdef SENSOR_49_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_49_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_49_PORT, SENSOR_49_PIN
;	bcf SENSOR_49_PORT, SENSOR_49_PIN
;retnow49:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_49_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade49	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_49_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately49

dofade49:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_49_ROLLING_TIMER_HIGH, f
	goto dontdofade49

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_49_PWM_SPEED
	movwf SENSOR_49_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_49_PWM_VOLUME
	subwf SENSOR_49_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade49		; Target = volume

	btfss STATUS, C
	goto fadedown49

	incf SENSOR_49_PWM_VOLUME, f		; fade up!
	goto dontdofade49
fadedown49:
	decf SENSOR_49_PWM_VOLUME, f		; fade down!
	goto dontdofade49
updateImmediately49:
	movfw SENSOR_49_PWM_TARGET
	movwf SENSOR_49_PWM_VOLUME

dontdofade49:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_49_ROLLING_TIMER_LOW
	subwf SENSOR_49_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit49

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_49_PORT, SENSOR_49_PIN
	goto retnow49

overlimit49:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_49_PORT, SENSOR_49_PIN

retnow49:

	#endif
#endif


#ifdef SENSOR_50_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_50_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_50_PORT, SENSOR_50_PIN
;	bcf SENSOR_50_PORT, SENSOR_50_PIN
;retnow50:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_50_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade50	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_50_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately50

dofade50:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_50_ROLLING_TIMER_HIGH, f
	goto dontdofade50

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_50_PWM_SPEED
	movwf SENSOR_50_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_50_PWM_VOLUME
	subwf SENSOR_50_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade50		; Target = volume

	btfss STATUS, C
	goto fadedown50

	incf SENSOR_50_PWM_VOLUME, f		; fade up!
	goto dontdofade50
fadedown50:
	decf SENSOR_50_PWM_VOLUME, f		; fade down!
	goto dontdofade50
updateImmediately50:
	movfw SENSOR_50_PWM_TARGET
	movwf SENSOR_50_PWM_VOLUME

dontdofade50:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_50_ROLLING_TIMER_LOW
	subwf SENSOR_50_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit50

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_50_PORT, SENSOR_50_PIN
	goto retnow50

overlimit50:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_50_PORT, SENSOR_50_PIN

retnow50:

	#endif
#endif


#ifdef SENSOR_51_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_51_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_51_PORT, SENSOR_51_PIN
;	bcf SENSOR_51_PORT, SENSOR_51_PIN
;retnow51:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_51_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade51	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_51_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately51

dofade51:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_51_ROLLING_TIMER_HIGH, f
	goto dontdofade51

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_51_PWM_SPEED
	movwf SENSOR_51_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_51_PWM_VOLUME
	subwf SENSOR_51_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade51		; Target = volume

	btfss STATUS, C
	goto fadedown51

	incf SENSOR_51_PWM_VOLUME, f		; fade up!
	goto dontdofade51
fadedown51:
	decf SENSOR_51_PWM_VOLUME, f		; fade down!
	goto dontdofade51
updateImmediately51:
	movfw SENSOR_51_PWM_TARGET
	movwf SENSOR_51_PWM_VOLUME

dontdofade51:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_51_ROLLING_TIMER_LOW
	subwf SENSOR_51_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit51

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_51_PORT, SENSOR_51_PIN
	goto retnow51

overlimit51:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_51_PORT, SENSOR_51_PIN

retnow51:

	#endif
#endif


#ifdef SENSOR_52_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_52_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_52_PORT, SENSOR_52_PIN
;	bcf SENSOR_52_PORT, SENSOR_52_PIN
;retnow52:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_52_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade52	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_52_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately52

dofade52:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_52_ROLLING_TIMER_HIGH, f
	goto dontdofade52

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_52_PWM_SPEED
	movwf SENSOR_52_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_52_PWM_VOLUME
	subwf SENSOR_52_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade52		; Target = volume

	btfss STATUS, C
	goto fadedown52

	incf SENSOR_52_PWM_VOLUME, f		; fade up!
	goto dontdofade52
fadedown52:
	decf SENSOR_52_PWM_VOLUME, f		; fade down!
	goto dontdofade52
updateImmediately52:
	movfw SENSOR_52_PWM_TARGET
	movwf SENSOR_52_PWM_VOLUME

dontdofade52:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_52_ROLLING_TIMER_LOW
	subwf SENSOR_52_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit52

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_52_PORT, SENSOR_52_PIN
	goto retnow52

overlimit52:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_52_PORT, SENSOR_52_PIN

retnow52:

	#endif
#endif


#ifdef SENSOR_53_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_53_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_53_PORT, SENSOR_53_PIN
;	bcf SENSOR_53_PORT, SENSOR_53_PIN
;retnow53:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_53_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade53	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_53_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately53

dofade53:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_53_ROLLING_TIMER_HIGH, f
	goto dontdofade53

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_53_PWM_SPEED
	movwf SENSOR_53_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_53_PWM_VOLUME
	subwf SENSOR_53_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade53		; Target = volume

	btfss STATUS, C
	goto fadedown53

	incf SENSOR_53_PWM_VOLUME, f		; fade up!
	goto dontdofade53
fadedown53:
	decf SENSOR_53_PWM_VOLUME, f		; fade down!
	goto dontdofade53
updateImmediately53:
	movfw SENSOR_53_PWM_TARGET
	movwf SENSOR_53_PWM_VOLUME

dontdofade53:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_53_ROLLING_TIMER_LOW
	subwf SENSOR_53_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit53

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_53_PORT, SENSOR_53_PIN
	goto retnow53

overlimit53:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_53_PORT, SENSOR_53_PIN

retnow53:

	#endif
#endif


#ifdef SENSOR_54_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_54_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_54_PORT, SENSOR_54_PIN
;	bcf SENSOR_54_PORT, SENSOR_54_PIN
;retnow54:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_54_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade54	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_54_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately54

dofade54:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_54_ROLLING_TIMER_HIGH, f
	goto dontdofade54

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_54_PWM_SPEED
	movwf SENSOR_54_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_54_PWM_VOLUME
	subwf SENSOR_54_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade54		; Target = volume

	btfss STATUS, C
	goto fadedown54

	incf SENSOR_54_PWM_VOLUME, f		; fade up!
	goto dontdofade54
fadedown54:
	decf SENSOR_54_PWM_VOLUME, f		; fade down!
	goto dontdofade54
updateImmediately54:
	movfw SENSOR_54_PWM_TARGET
	movwf SENSOR_54_PWM_VOLUME

dontdofade54:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_54_ROLLING_TIMER_LOW
	subwf SENSOR_54_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit54

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_54_PORT, SENSOR_54_PIN
	goto retnow54

overlimit54:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_54_PORT, SENSOR_54_PIN

retnow54:

	#endif
#endif


#ifdef SENSOR_55_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_55_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_55_PORT, SENSOR_55_PIN
;	bcf SENSOR_55_PORT, SENSOR_55_PIN
;retnow55:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_55_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade55	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_55_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately55

dofade55:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_55_ROLLING_TIMER_HIGH, f
	goto dontdofade55

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_55_PWM_SPEED
	movwf SENSOR_55_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_55_PWM_VOLUME
	subwf SENSOR_55_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade55		; Target = volume

	btfss STATUS, C
	goto fadedown55

	incf SENSOR_55_PWM_VOLUME, f		; fade up!
	goto dontdofade55
fadedown55:
	decf SENSOR_55_PWM_VOLUME, f		; fade down!
	goto dontdofade55
updateImmediately55:
	movfw SENSOR_55_PWM_TARGET
	movwf SENSOR_55_PWM_VOLUME

dontdofade55:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_55_ROLLING_TIMER_LOW
	subwf SENSOR_55_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit55

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_55_PORT, SENSOR_55_PIN
	goto retnow55

overlimit55:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_55_PORT, SENSOR_55_PIN

retnow55:

	#endif
#endif


#ifdef SENSOR_56_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_56_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_56_PORT, SENSOR_56_PIN
;	bcf SENSOR_56_PORT, SENSOR_56_PIN
;retnow56:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_56_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade56	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_56_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately56

dofade56:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_56_ROLLING_TIMER_HIGH, f
	goto dontdofade56

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_56_PWM_SPEED
	movwf SENSOR_56_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_56_PWM_VOLUME
	subwf SENSOR_56_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade56		; Target = volume

	btfss STATUS, C
	goto fadedown56

	incf SENSOR_56_PWM_VOLUME, f		; fade up!
	goto dontdofade56
fadedown56:
	decf SENSOR_56_PWM_VOLUME, f		; fade down!
	goto dontdofade56
updateImmediately56:
	movfw SENSOR_56_PWM_TARGET
	movwf SENSOR_56_PWM_VOLUME

dontdofade56:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_56_ROLLING_TIMER_LOW
	subwf SENSOR_56_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit56

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_56_PORT, SENSOR_56_PIN
	goto retnow56

overlimit56:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_56_PORT, SENSOR_56_PIN

retnow56:

	#endif
#endif


#ifdef SENSOR_57_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_57_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_57_PORT, SENSOR_57_PIN
;	bcf SENSOR_57_PORT, SENSOR_57_PIN
;retnow57:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_57_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade57	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_57_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately57

dofade57:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_57_ROLLING_TIMER_HIGH, f
	goto dontdofade57

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_57_PWM_SPEED
	movwf SENSOR_57_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_57_PWM_VOLUME
	subwf SENSOR_57_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade57		; Target = volume

	btfss STATUS, C
	goto fadedown57

	incf SENSOR_57_PWM_VOLUME, f		; fade up!
	goto dontdofade57
fadedown57:
	decf SENSOR_57_PWM_VOLUME, f		; fade down!
	goto dontdofade57
updateImmediately57:
	movfw SENSOR_57_PWM_TARGET
	movwf SENSOR_57_PWM_VOLUME

dontdofade57:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_57_ROLLING_TIMER_LOW
	subwf SENSOR_57_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit57

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_57_PORT, SENSOR_57_PIN
	goto retnow57

overlimit57:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_57_PORT, SENSOR_57_PIN

retnow57:

	#endif
#endif


#ifdef SENSOR_58_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_58_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_58_PORT, SENSOR_58_PIN
;	bcf SENSOR_58_PORT, SENSOR_58_PIN
;retnow58:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_58_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade58	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_58_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately58

dofade58:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_58_ROLLING_TIMER_HIGH, f
	goto dontdofade58

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_58_PWM_SPEED
	movwf SENSOR_58_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_58_PWM_VOLUME
	subwf SENSOR_58_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade58		; Target = volume

	btfss STATUS, C
	goto fadedown58

	incf SENSOR_58_PWM_VOLUME, f		; fade up!
	goto dontdofade58
fadedown58:
	decf SENSOR_58_PWM_VOLUME, f		; fade down!
	goto dontdofade58
updateImmediately58:
	movfw SENSOR_58_PWM_TARGET
	movwf SENSOR_58_PWM_VOLUME

dontdofade58:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_58_ROLLING_TIMER_LOW
	subwf SENSOR_58_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit58

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_58_PORT, SENSOR_58_PIN
	goto retnow58

overlimit58:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_58_PORT, SENSOR_58_PIN

retnow58:

	#endif
#endif


#ifdef SENSOR_59_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_59_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_59_PORT, SENSOR_59_PIN
;	bcf SENSOR_59_PORT, SENSOR_59_PIN
;retnow59:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_59_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade59	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_59_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately59

dofade59:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_59_ROLLING_TIMER_HIGH, f
	goto dontdofade59

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_59_PWM_SPEED
	movwf SENSOR_59_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_59_PWM_VOLUME
	subwf SENSOR_59_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade59		; Target = volume

	btfss STATUS, C
	goto fadedown59

	incf SENSOR_59_PWM_VOLUME, f		; fade up!
	goto dontdofade59
fadedown59:
	decf SENSOR_59_PWM_VOLUME, f		; fade down!
	goto dontdofade59
updateImmediately59:
	movfw SENSOR_59_PWM_TARGET
	movwf SENSOR_59_PWM_VOLUME

dontdofade59:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_59_ROLLING_TIMER_LOW
	subwf SENSOR_59_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit59

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_59_PORT, SENSOR_59_PIN
	goto retnow59

overlimit59:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_59_PORT, SENSOR_59_PIN

retnow59:

	#endif
#endif


#ifdef SENSOR_60_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_60_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_60_PORT, SENSOR_60_PIN
;	bcf SENSOR_60_PORT, SENSOR_60_PIN
;retnow60:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_60_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade60	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_60_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately60

dofade60:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_60_ROLLING_TIMER_HIGH, f
	goto dontdofade60

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_60_PWM_SPEED
	movwf SENSOR_60_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_60_PWM_VOLUME
	subwf SENSOR_60_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade60		; Target = volume

	btfss STATUS, C
	goto fadedown60

	incf SENSOR_60_PWM_VOLUME, f		; fade up!
	goto dontdofade60
fadedown60:
	decf SENSOR_60_PWM_VOLUME, f		; fade down!
	goto dontdofade60
updateImmediately60:
	movfw SENSOR_60_PWM_TARGET
	movwf SENSOR_60_PWM_VOLUME

dontdofade60:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_60_ROLLING_TIMER_LOW
	subwf SENSOR_60_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit60

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_60_PORT, SENSOR_60_PIN
	goto retnow60

overlimit60:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_60_PORT, SENSOR_60_PIN

retnow60:

	#endif
#endif


#ifdef SENSOR_61_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_61_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_61_PORT, SENSOR_61_PIN
;	bcf SENSOR_61_PORT, SENSOR_61_PIN
;retnow61:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_61_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade61	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_61_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately61

dofade61:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_61_ROLLING_TIMER_HIGH, f
	goto dontdofade61

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_61_PWM_SPEED
	movwf SENSOR_61_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_61_PWM_VOLUME
	subwf SENSOR_61_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade61		; Target = volume

	btfss STATUS, C
	goto fadedown61

	incf SENSOR_61_PWM_VOLUME, f		; fade up!
	goto dontdofade61
fadedown61:
	decf SENSOR_61_PWM_VOLUME, f		; fade down!
	goto dontdofade61
updateImmediately61:
	movfw SENSOR_61_PWM_TARGET
	movwf SENSOR_61_PWM_VOLUME

dontdofade61:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_61_ROLLING_TIMER_LOW
	subwf SENSOR_61_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit61

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_61_PORT, SENSOR_61_PIN
	goto retnow61

overlimit61:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_61_PORT, SENSOR_61_PIN

retnow61:

	#endif
#endif


#ifdef SENSOR_62_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_62_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_62_PORT, SENSOR_62_PIN
;	bcf SENSOR_62_PORT, SENSOR_62_PIN
;retnow62:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_62_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade62	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_62_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately62

dofade62:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_62_ROLLING_TIMER_HIGH, f
	goto dontdofade62

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_62_PWM_SPEED
	movwf SENSOR_62_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_62_PWM_VOLUME
	subwf SENSOR_62_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade62		; Target = volume

	btfss STATUS, C
	goto fadedown62

	incf SENSOR_62_PWM_VOLUME, f		; fade up!
	goto dontdofade62
fadedown62:
	decf SENSOR_62_PWM_VOLUME, f		; fade down!
	goto dontdofade62
updateImmediately62:
	movfw SENSOR_62_PWM_TARGET
	movwf SENSOR_62_PWM_VOLUME

dontdofade62:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_62_ROLLING_TIMER_LOW
	subwf SENSOR_62_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit62

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_62_PORT, SENSOR_62_PIN
	goto retnow62

overlimit62:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_62_PORT, SENSOR_62_PIN

retnow62:

	#endif
#endif


#ifdef SENSOR_63_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_63_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_63_PORT, SENSOR_63_PIN
;	bcf SENSOR_63_PORT, SENSOR_63_PIN
;retnow63:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_63_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade63	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_63_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately63

dofade63:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_63_ROLLING_TIMER_HIGH, f
	goto dontdofade63

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_63_PWM_SPEED
	movwf SENSOR_63_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_63_PWM_VOLUME
	subwf SENSOR_63_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade63		; Target = volume

	btfss STATUS, C
	goto fadedown63

	incf SENSOR_63_PWM_VOLUME, f		; fade up!
	goto dontdofade63
fadedown63:
	decf SENSOR_63_PWM_VOLUME, f		; fade down!
	goto dontdofade63
updateImmediately63:
	movfw SENSOR_63_PWM_TARGET
	movwf SENSOR_63_PWM_VOLUME

dontdofade63:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_63_ROLLING_TIMER_LOW
	subwf SENSOR_63_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit63

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_63_PORT, SENSOR_63_PIN
	goto retnow63

overlimit63:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_63_PORT, SENSOR_63_PIN

retnow63:

	#endif
#endif


#ifdef SENSOR_64_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_64_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_64_PORT, SENSOR_64_PIN
;	bcf SENSOR_64_PORT, SENSOR_64_PIN
;retnow64:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_64_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade64	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_64_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately64

dofade64:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_64_ROLLING_TIMER_HIGH, f
	goto dontdofade64

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_64_PWM_SPEED
	movwf SENSOR_64_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_64_PWM_VOLUME
	subwf SENSOR_64_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade64		; Target = volume

	btfss STATUS, C
	goto fadedown64

	incf SENSOR_64_PWM_VOLUME, f		; fade up!
	goto dontdofade64
fadedown64:
	decf SENSOR_64_PWM_VOLUME, f		; fade down!
	goto dontdofade64
updateImmediately64:
	movfw SENSOR_64_PWM_TARGET
	movwf SENSOR_64_PWM_VOLUME

dontdofade64:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_64_ROLLING_TIMER_LOW
	subwf SENSOR_64_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit64

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_64_PORT, SENSOR_64_PIN
	goto retnow64

overlimit64:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_64_PORT, SENSOR_64_PIN

retnow64:

	#endif
#endif


#ifdef SENSOR_65_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_65_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_65_PORT, SENSOR_65_PIN
;	bcf SENSOR_65_PORT, SENSOR_65_PIN
;retnow65:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_65_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade65	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_65_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately65

dofade65:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_65_ROLLING_TIMER_HIGH, f
	goto dontdofade65

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_65_PWM_SPEED
	movwf SENSOR_65_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_65_PWM_VOLUME
	subwf SENSOR_65_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade65		; Target = volume

	btfss STATUS, C
	goto fadedown65

	incf SENSOR_65_PWM_VOLUME, f		; fade up!
	goto dontdofade65
fadedown65:
	decf SENSOR_65_PWM_VOLUME, f		; fade down!
	goto dontdofade65
updateImmediately65:
	movfw SENSOR_65_PWM_TARGET
	movwf SENSOR_65_PWM_VOLUME

dontdofade65:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_65_ROLLING_TIMER_LOW
	subwf SENSOR_65_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit65

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_65_PORT, SENSOR_65_PIN
	goto retnow65

overlimit65:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_65_PORT, SENSOR_65_PIN

retnow65:

	#endif
#endif


#ifdef SENSOR_66_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_66_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_66_PORT, SENSOR_66_PIN
;	bcf SENSOR_66_PORT, SENSOR_66_PIN
;retnow66:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_66_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade66	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_66_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately66

dofade66:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_66_ROLLING_TIMER_HIGH, f
	goto dontdofade66

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_66_PWM_SPEED
	movwf SENSOR_66_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_66_PWM_VOLUME
	subwf SENSOR_66_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade66		; Target = volume

	btfss STATUS, C
	goto fadedown66

	incf SENSOR_66_PWM_VOLUME, f		; fade up!
	goto dontdofade66
fadedown66:
	decf SENSOR_66_PWM_VOLUME, f		; fade down!
	goto dontdofade66
updateImmediately66:
	movfw SENSOR_66_PWM_TARGET
	movwf SENSOR_66_PWM_VOLUME

dontdofade66:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_66_ROLLING_TIMER_LOW
	subwf SENSOR_66_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit66

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_66_PORT, SENSOR_66_PIN
	goto retnow66

overlimit66:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_66_PORT, SENSOR_66_PIN

retnow66:

	#endif
#endif


#ifdef SENSOR_67_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_67_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_67_PORT, SENSOR_67_PIN
;	bcf SENSOR_67_PORT, SENSOR_67_PIN
;retnow67:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_67_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade67	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_67_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately67

dofade67:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_67_ROLLING_TIMER_HIGH, f
	goto dontdofade67

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_67_PWM_SPEED
	movwf SENSOR_67_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_67_PWM_VOLUME
	subwf SENSOR_67_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade67		; Target = volume

	btfss STATUS, C
	goto fadedown67

	incf SENSOR_67_PWM_VOLUME, f		; fade up!
	goto dontdofade67
fadedown67:
	decf SENSOR_67_PWM_VOLUME, f		; fade down!
	goto dontdofade67
updateImmediately67:
	movfw SENSOR_67_PWM_TARGET
	movwf SENSOR_67_PWM_VOLUME

dontdofade67:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_67_ROLLING_TIMER_LOW
	subwf SENSOR_67_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit67

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_67_PORT, SENSOR_67_PIN
	goto retnow67

overlimit67:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_67_PORT, SENSOR_67_PIN

retnow67:

	#endif
#endif


#ifdef SENSOR_68_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_68_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_68_PORT, SENSOR_68_PIN
;	bcf SENSOR_68_PORT, SENSOR_68_PIN
;retnow68:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_68_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade68	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_68_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately68

dofade68:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_68_ROLLING_TIMER_HIGH, f
	goto dontdofade68

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_68_PWM_SPEED
	movwf SENSOR_68_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_68_PWM_VOLUME
	subwf SENSOR_68_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade68		; Target = volume

	btfss STATUS, C
	goto fadedown68

	incf SENSOR_68_PWM_VOLUME, f		; fade up!
	goto dontdofade68
fadedown68:
	decf SENSOR_68_PWM_VOLUME, f		; fade down!
	goto dontdofade68
updateImmediately68:
	movfw SENSOR_68_PWM_TARGET
	movwf SENSOR_68_PWM_VOLUME

dontdofade68:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_68_ROLLING_TIMER_LOW
	subwf SENSOR_68_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit68

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_68_PORT, SENSOR_68_PIN
	goto retnow68

overlimit68:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_68_PORT, SENSOR_68_PIN

retnow68:

	#endif
#endif


#ifdef SENSOR_69_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_69_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_69_PORT, SENSOR_69_PIN
;	bcf SENSOR_69_PORT, SENSOR_69_PIN
;retnow69:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_69_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade69	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_69_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately69

dofade69:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_69_ROLLING_TIMER_HIGH, f
	goto dontdofade69

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_69_PWM_SPEED
	movwf SENSOR_69_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_69_PWM_VOLUME
	subwf SENSOR_69_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade69		; Target = volume

	btfss STATUS, C
	goto fadedown69

	incf SENSOR_69_PWM_VOLUME, f		; fade up!
	goto dontdofade69
fadedown69:
	decf SENSOR_69_PWM_VOLUME, f		; fade down!
	goto dontdofade69
updateImmediately69:
	movfw SENSOR_69_PWM_TARGET
	movwf SENSOR_69_PWM_VOLUME

dontdofade69:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_69_ROLLING_TIMER_LOW
	subwf SENSOR_69_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit69

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_69_PORT, SENSOR_69_PIN
	goto retnow69

overlimit69:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_69_PORT, SENSOR_69_PIN

retnow69:

	#endif
#endif


#ifdef SENSOR_70_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_70_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_70_PORT, SENSOR_70_PIN
;	bcf SENSOR_70_PORT, SENSOR_70_PIN
;retnow70:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_70_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade70	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_70_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately70

dofade70:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_70_ROLLING_TIMER_HIGH, f
	goto dontdofade70

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_70_PWM_SPEED
	movwf SENSOR_70_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_70_PWM_VOLUME
	subwf SENSOR_70_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade70		; Target = volume

	btfss STATUS, C
	goto fadedown70

	incf SENSOR_70_PWM_VOLUME, f		; fade up!
	goto dontdofade70
fadedown70:
	decf SENSOR_70_PWM_VOLUME, f		; fade down!
	goto dontdofade70
updateImmediately70:
	movfw SENSOR_70_PWM_TARGET
	movwf SENSOR_70_PWM_VOLUME

dontdofade70:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_70_ROLLING_TIMER_LOW
	subwf SENSOR_70_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit70

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_70_PORT, SENSOR_70_PIN
	goto retnow70

overlimit70:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_70_PORT, SENSOR_70_PIN

retnow70:

	#endif
#endif


#ifdef SENSOR_71_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_71_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_71_PORT, SENSOR_71_PIN
;	bcf SENSOR_71_PORT, SENSOR_71_PIN
;retnow71:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_71_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade71	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_71_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately71

dofade71:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_71_ROLLING_TIMER_HIGH, f
	goto dontdofade71

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_71_PWM_SPEED
	movwf SENSOR_71_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_71_PWM_VOLUME
	subwf SENSOR_71_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade71		; Target = volume

	btfss STATUS, C
	goto fadedown71

	incf SENSOR_71_PWM_VOLUME, f		; fade up!
	goto dontdofade71
fadedown71:
	decf SENSOR_71_PWM_VOLUME, f		; fade down!
	goto dontdofade71
updateImmediately71:
	movfw SENSOR_71_PWM_TARGET
	movwf SENSOR_71_PWM_VOLUME

dontdofade71:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_71_ROLLING_TIMER_LOW
	subwf SENSOR_71_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit71

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_71_PORT, SENSOR_71_PIN
	goto retnow71

overlimit71:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_71_PORT, SENSOR_71_PIN

retnow71:

	#endif
#endif


#ifdef SENSOR_72_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_72_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_72_PORT, SENSOR_72_PIN
;	bcf SENSOR_72_PORT, SENSOR_72_PIN
;retnow72:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_72_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade72	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_72_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately72

dofade72:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_72_ROLLING_TIMER_HIGH, f
	goto dontdofade72

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_72_PWM_SPEED
	movwf SENSOR_72_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_72_PWM_VOLUME
	subwf SENSOR_72_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade72		; Target = volume

	btfss STATUS, C
	goto fadedown72

	incf SENSOR_72_PWM_VOLUME, f		; fade up!
	goto dontdofade72
fadedown72:
	decf SENSOR_72_PWM_VOLUME, f		; fade down!
	goto dontdofade72
updateImmediately72:
	movfw SENSOR_72_PWM_TARGET
	movwf SENSOR_72_PWM_VOLUME

dontdofade72:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_72_ROLLING_TIMER_LOW
	subwf SENSOR_72_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit72

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_72_PORT, SENSOR_72_PIN
	goto retnow72

overlimit72:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_72_PORT, SENSOR_72_PIN

retnow72:

	#endif
#endif


#ifdef SENSOR_73_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_73_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_73_PORT, SENSOR_73_PIN
;	bcf SENSOR_73_PORT, SENSOR_73_PIN
;retnow73:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_73_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade73	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_73_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately73

dofade73:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_73_ROLLING_TIMER_HIGH, f
	goto dontdofade73

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_73_PWM_SPEED
	movwf SENSOR_73_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_73_PWM_VOLUME
	subwf SENSOR_73_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade73		; Target = volume

	btfss STATUS, C
	goto fadedown73

	incf SENSOR_73_PWM_VOLUME, f		; fade up!
	goto dontdofade73
fadedown73:
	decf SENSOR_73_PWM_VOLUME, f		; fade down!
	goto dontdofade73
updateImmediately73:
	movfw SENSOR_73_PWM_TARGET
	movwf SENSOR_73_PWM_VOLUME

dontdofade73:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_73_ROLLING_TIMER_LOW
	subwf SENSOR_73_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit73

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_73_PORT, SENSOR_73_PIN
	goto retnow73

overlimit73:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_73_PORT, SENSOR_73_PIN

retnow73:

	#endif
#endif


#ifdef SENSOR_74_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_74_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_74_PORT, SENSOR_74_PIN
;	bcf SENSOR_74_PORT, SENSOR_74_PIN
;retnow74:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_74_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade74	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_74_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately74

dofade74:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_74_ROLLING_TIMER_HIGH, f
	goto dontdofade74

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_74_PWM_SPEED
	movwf SENSOR_74_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_74_PWM_VOLUME
	subwf SENSOR_74_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade74		; Target = volume

	btfss STATUS, C
	goto fadedown74

	incf SENSOR_74_PWM_VOLUME, f		; fade up!
	goto dontdofade74
fadedown74:
	decf SENSOR_74_PWM_VOLUME, f		; fade down!
	goto dontdofade74
updateImmediately74:
	movfw SENSOR_74_PWM_TARGET
	movwf SENSOR_74_PWM_VOLUME

dontdofade74:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_74_ROLLING_TIMER_LOW
	subwf SENSOR_74_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit74

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_74_PORT, SENSOR_74_PIN
	goto retnow74

overlimit74:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_74_PORT, SENSOR_74_PIN

retnow74:

	#endif
#endif


#ifdef SENSOR_75_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_75_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_75_PORT, SENSOR_75_PIN
;	bcf SENSOR_75_PORT, SENSOR_75_PIN
;retnow75:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_75_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade75	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_75_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately75

dofade75:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_75_ROLLING_TIMER_HIGH, f
	goto dontdofade75

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_75_PWM_SPEED
	movwf SENSOR_75_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_75_PWM_VOLUME
	subwf SENSOR_75_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade75		; Target = volume

	btfss STATUS, C
	goto fadedown75

	incf SENSOR_75_PWM_VOLUME, f		; fade up!
	goto dontdofade75
fadedown75:
	decf SENSOR_75_PWM_VOLUME, f		; fade down!
	goto dontdofade75
updateImmediately75:
	movfw SENSOR_75_PWM_TARGET
	movwf SENSOR_75_PWM_VOLUME

dontdofade75:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_75_ROLLING_TIMER_LOW
	subwf SENSOR_75_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit75

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_75_PORT, SENSOR_75_PIN
	goto retnow75

overlimit75:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_75_PORT, SENSOR_75_PIN

retnow75:

	#endif
#endif


#ifdef SENSOR_76_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_76_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_76_PORT, SENSOR_76_PIN
;	bcf SENSOR_76_PORT, SENSOR_76_PIN
;retnow76:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_76_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade76	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_76_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately76

dofade76:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_76_ROLLING_TIMER_HIGH, f
	goto dontdofade76

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_76_PWM_SPEED
	movwf SENSOR_76_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_76_PWM_VOLUME
	subwf SENSOR_76_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade76		; Target = volume

	btfss STATUS, C
	goto fadedown76

	incf SENSOR_76_PWM_VOLUME, f		; fade up!
	goto dontdofade76
fadedown76:
	decf SENSOR_76_PWM_VOLUME, f		; fade down!
	goto dontdofade76
updateImmediately76:
	movfw SENSOR_76_PWM_TARGET
	movwf SENSOR_76_PWM_VOLUME

dontdofade76:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_76_ROLLING_TIMER_LOW
	subwf SENSOR_76_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit76

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_76_PORT, SENSOR_76_PIN
	goto retnow76

overlimit76:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_76_PORT, SENSOR_76_PIN

retnow76:

	#endif
#endif


#ifdef SENSOR_77_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_77_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_77_PORT, SENSOR_77_PIN
;	bcf SENSOR_77_PORT, SENSOR_77_PIN
;retnow77:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_77_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade77	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_77_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately77

dofade77:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_77_ROLLING_TIMER_HIGH, f
	goto dontdofade77

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_77_PWM_SPEED
	movwf SENSOR_77_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_77_PWM_VOLUME
	subwf SENSOR_77_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade77		; Target = volume

	btfss STATUS, C
	goto fadedown77

	incf SENSOR_77_PWM_VOLUME, f		; fade up!
	goto dontdofade77
fadedown77:
	decf SENSOR_77_PWM_VOLUME, f		; fade down!
	goto dontdofade77
updateImmediately77:
	movfw SENSOR_77_PWM_TARGET
	movwf SENSOR_77_PWM_VOLUME

dontdofade77:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_77_ROLLING_TIMER_LOW
	subwf SENSOR_77_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit77

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_77_PORT, SENSOR_77_PIN
	goto retnow77

overlimit77:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_77_PORT, SENSOR_77_PIN

retnow77:

	#endif
#endif


#ifdef SENSOR_78_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_78_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_78_PORT, SENSOR_78_PIN
;	bcf SENSOR_78_PORT, SENSOR_78_PIN
;retnow78:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_78_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade78	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_78_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately78

dofade78:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_78_ROLLING_TIMER_HIGH, f
	goto dontdofade78

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_78_PWM_SPEED
	movwf SENSOR_78_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_78_PWM_VOLUME
	subwf SENSOR_78_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade78		; Target = volume

	btfss STATUS, C
	goto fadedown78

	incf SENSOR_78_PWM_VOLUME, f		; fade up!
	goto dontdofade78
fadedown78:
	decf SENSOR_78_PWM_VOLUME, f		; fade down!
	goto dontdofade78
updateImmediately78:
	movfw SENSOR_78_PWM_TARGET
	movwf SENSOR_78_PWM_VOLUME

dontdofade78:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_78_ROLLING_TIMER_LOW
	subwf SENSOR_78_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit78

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_78_PORT, SENSOR_78_PIN
	goto retnow78

overlimit78:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_78_PORT, SENSOR_78_PIN

retnow78:

	#endif
#endif


#ifdef SENSOR_79_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_79_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_79_PORT, SENSOR_79_PIN
;	bcf SENSOR_79_PORT, SENSOR_79_PIN
;retnow79:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_79_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade79	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_79_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately79

dofade79:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_79_ROLLING_TIMER_HIGH, f
	goto dontdofade79

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_79_PWM_SPEED
	movwf SENSOR_79_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_79_PWM_VOLUME
	subwf SENSOR_79_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade79		; Target = volume

	btfss STATUS, C
	goto fadedown79

	incf SENSOR_79_PWM_VOLUME, f		; fade up!
	goto dontdofade79
fadedown79:
	decf SENSOR_79_PWM_VOLUME, f		; fade down!
	goto dontdofade79
updateImmediately79:
	movfw SENSOR_79_PWM_TARGET
	movwf SENSOR_79_PWM_VOLUME

dontdofade79:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_79_ROLLING_TIMER_LOW
	subwf SENSOR_79_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit79

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_79_PORT, SENSOR_79_PIN
	goto retnow79

overlimit79:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_79_PORT, SENSOR_79_PIN

retnow79:

	#endif
#endif


#ifdef SENSOR_80_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_80_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_80_PORT, SENSOR_80_PIN
;	bcf SENSOR_80_PORT, SENSOR_80_PIN
;retnow80:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_80_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade80	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_80_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately80

dofade80:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_80_ROLLING_TIMER_HIGH, f
	goto dontdofade80

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_80_PWM_SPEED
	movwf SENSOR_80_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_80_PWM_VOLUME
	subwf SENSOR_80_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade80		; Target = volume

	btfss STATUS, C
	goto fadedown80

	incf SENSOR_80_PWM_VOLUME, f		; fade up!
	goto dontdofade80
fadedown80:
	decf SENSOR_80_PWM_VOLUME, f		; fade down!
	goto dontdofade80
updateImmediately80:
	movfw SENSOR_80_PWM_TARGET
	movwf SENSOR_80_PWM_VOLUME

dontdofade80:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_80_ROLLING_TIMER_LOW
	subwf SENSOR_80_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit80

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_80_PORT, SENSOR_80_PIN
	goto retnow80

overlimit80:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_80_PORT, SENSOR_80_PIN

retnow80:

	#endif
#endif


#ifdef SENSOR_81_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_81_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_81_PORT, SENSOR_81_PIN
;	bcf SENSOR_81_PORT, SENSOR_81_PIN
;retnow81:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_81_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade81	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_81_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately81

dofade81:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_81_ROLLING_TIMER_HIGH, f
	goto dontdofade81

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_81_PWM_SPEED
	movwf SENSOR_81_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_81_PWM_VOLUME
	subwf SENSOR_81_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade81		; Target = volume

	btfss STATUS, C
	goto fadedown81

	incf SENSOR_81_PWM_VOLUME, f		; fade up!
	goto dontdofade81
fadedown81:
	decf SENSOR_81_PWM_VOLUME, f		; fade down!
	goto dontdofade81
updateImmediately81:
	movfw SENSOR_81_PWM_TARGET
	movwf SENSOR_81_PWM_VOLUME

dontdofade81:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_81_ROLLING_TIMER_LOW
	subwf SENSOR_81_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit81

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_81_PORT, SENSOR_81_PIN
	goto retnow81

overlimit81:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_81_PORT, SENSOR_81_PIN

retnow81:

	#endif
#endif


#ifdef SENSOR_82_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_82_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_82_PORT, SENSOR_82_PIN
;	bcf SENSOR_82_PORT, SENSOR_82_PIN
;retnow82:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_82_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade82	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_82_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately82

dofade82:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_82_ROLLING_TIMER_HIGH, f
	goto dontdofade82

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_82_PWM_SPEED
	movwf SENSOR_82_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_82_PWM_VOLUME
	subwf SENSOR_82_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade82		; Target = volume

	btfss STATUS, C
	goto fadedown82

	incf SENSOR_82_PWM_VOLUME, f		; fade up!
	goto dontdofade82
fadedown82:
	decf SENSOR_82_PWM_VOLUME, f		; fade down!
	goto dontdofade82
updateImmediately82:
	movfw SENSOR_82_PWM_TARGET
	movwf SENSOR_82_PWM_VOLUME

dontdofade82:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_82_ROLLING_TIMER_LOW
	subwf SENSOR_82_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit82

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_82_PORT, SENSOR_82_PIN
	goto retnow82

overlimit82:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_82_PORT, SENSOR_82_PIN

retnow82:

	#endif
#endif


#ifdef SENSOR_83_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_83_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_83_PORT, SENSOR_83_PIN
;	bcf SENSOR_83_PORT, SENSOR_83_PIN
;retnow83:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_83_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade83	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_83_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately83

dofade83:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_83_ROLLING_TIMER_HIGH, f
	goto dontdofade83

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_83_PWM_SPEED
	movwf SENSOR_83_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_83_PWM_VOLUME
	subwf SENSOR_83_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade83		; Target = volume

	btfss STATUS, C
	goto fadedown83

	incf SENSOR_83_PWM_VOLUME, f		; fade up!
	goto dontdofade83
fadedown83:
	decf SENSOR_83_PWM_VOLUME, f		; fade down!
	goto dontdofade83
updateImmediately83:
	movfw SENSOR_83_PWM_TARGET
	movwf SENSOR_83_PWM_VOLUME

dontdofade83:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_83_ROLLING_TIMER_LOW
	subwf SENSOR_83_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit83

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_83_PORT, SENSOR_83_PIN
	goto retnow83

overlimit83:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_83_PORT, SENSOR_83_PIN

retnow83:

	#endif
#endif


#ifdef SENSOR_84_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_84_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_84_PORT, SENSOR_84_PIN
;	bcf SENSOR_84_PORT, SENSOR_84_PIN
;retnow84:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_84_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade84	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_84_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately84

dofade84:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_84_ROLLING_TIMER_HIGH, f
	goto dontdofade84

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_84_PWM_SPEED
	movwf SENSOR_84_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_84_PWM_VOLUME
	subwf SENSOR_84_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade84		; Target = volume

	btfss STATUS, C
	goto fadedown84

	incf SENSOR_84_PWM_VOLUME, f		; fade up!
	goto dontdofade84
fadedown84:
	decf SENSOR_84_PWM_VOLUME, f		; fade down!
	goto dontdofade84
updateImmediately84:
	movfw SENSOR_84_PWM_TARGET
	movwf SENSOR_84_PWM_VOLUME

dontdofade84:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_84_ROLLING_TIMER_LOW
	subwf SENSOR_84_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit84

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_84_PORT, SENSOR_84_PIN
	goto retnow84

overlimit84:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_84_PORT, SENSOR_84_PIN

retnow84:

	#endif
#endif


#ifdef SENSOR_85_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_85_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_85_PORT, SENSOR_85_PIN
;	bcf SENSOR_85_PORT, SENSOR_85_PIN
;retnow85:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_85_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade85	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_85_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately85

dofade85:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_85_ROLLING_TIMER_HIGH, f
	goto dontdofade85

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_85_PWM_SPEED
	movwf SENSOR_85_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_85_PWM_VOLUME
	subwf SENSOR_85_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade85		; Target = volume

	btfss STATUS, C
	goto fadedown85

	incf SENSOR_85_PWM_VOLUME, f		; fade up!
	goto dontdofade85
fadedown85:
	decf SENSOR_85_PWM_VOLUME, f		; fade down!
	goto dontdofade85
updateImmediately85:
	movfw SENSOR_85_PWM_TARGET
	movwf SENSOR_85_PWM_VOLUME

dontdofade85:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_85_ROLLING_TIMER_LOW
	subwf SENSOR_85_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit85

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_85_PORT, SENSOR_85_PIN
	goto retnow85

overlimit85:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_85_PORT, SENSOR_85_PIN

retnow85:

	#endif
#endif


#ifdef SENSOR_86_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_86_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_86_PORT, SENSOR_86_PIN
;	bcf SENSOR_86_PORT, SENSOR_86_PIN
;retnow86:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_86_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade86	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_86_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately86

dofade86:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_86_ROLLING_TIMER_HIGH, f
	goto dontdofade86

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_86_PWM_SPEED
	movwf SENSOR_86_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_86_PWM_VOLUME
	subwf SENSOR_86_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade86		; Target = volume

	btfss STATUS, C
	goto fadedown86

	incf SENSOR_86_PWM_VOLUME, f		; fade up!
	goto dontdofade86
fadedown86:
	decf SENSOR_86_PWM_VOLUME, f		; fade down!
	goto dontdofade86
updateImmediately86:
	movfw SENSOR_86_PWM_TARGET
	movwf SENSOR_86_PWM_VOLUME

dontdofade86:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_86_ROLLING_TIMER_LOW
	subwf SENSOR_86_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit86

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_86_PORT, SENSOR_86_PIN
	goto retnow86

overlimit86:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_86_PORT, SENSOR_86_PIN

retnow86:

	#endif
#endif


#ifdef SENSOR_87_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_87_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_87_PORT, SENSOR_87_PIN
;	bcf SENSOR_87_PORT, SENSOR_87_PIN
;retnow87:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_87_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade87	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_87_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately87

dofade87:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_87_ROLLING_TIMER_HIGH, f
	goto dontdofade87

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_87_PWM_SPEED
	movwf SENSOR_87_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_87_PWM_VOLUME
	subwf SENSOR_87_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade87		; Target = volume

	btfss STATUS, C
	goto fadedown87

	incf SENSOR_87_PWM_VOLUME, f		; fade up!
	goto dontdofade87
fadedown87:
	decf SENSOR_87_PWM_VOLUME, f		; fade down!
	goto dontdofade87
updateImmediately87:
	movfw SENSOR_87_PWM_TARGET
	movwf SENSOR_87_PWM_VOLUME

dontdofade87:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_87_ROLLING_TIMER_LOW
	subwf SENSOR_87_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit87

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_87_PORT, SENSOR_87_PIN
	goto retnow87

overlimit87:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_87_PORT, SENSOR_87_PIN

retnow87:

	#endif
#endif


#ifdef SENSOR_88_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_88_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_88_PORT, SENSOR_88_PIN
;	bcf SENSOR_88_PORT, SENSOR_88_PIN
;retnow88:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_88_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade88	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_88_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately88

dofade88:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_88_ROLLING_TIMER_HIGH, f
	goto dontdofade88

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_88_PWM_SPEED
	movwf SENSOR_88_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_88_PWM_VOLUME
	subwf SENSOR_88_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade88		; Target = volume

	btfss STATUS, C
	goto fadedown88

	incf SENSOR_88_PWM_VOLUME, f		; fade up!
	goto dontdofade88
fadedown88:
	decf SENSOR_88_PWM_VOLUME, f		; fade down!
	goto dontdofade88
updateImmediately88:
	movfw SENSOR_88_PWM_TARGET
	movwf SENSOR_88_PWM_VOLUME

dontdofade88:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_88_ROLLING_TIMER_LOW
	subwf SENSOR_88_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit88

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_88_PORT, SENSOR_88_PIN
	goto retnow88

overlimit88:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_88_PORT, SENSOR_88_PIN

retnow88:

	#endif
#endif


#ifdef SENSOR_89_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_89_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_89_PORT, SENSOR_89_PIN
;	bcf SENSOR_89_PORT, SENSOR_89_PIN
;retnow89:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_89_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade89	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_89_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately89

dofade89:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_89_ROLLING_TIMER_HIGH, f
	goto dontdofade89

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_89_PWM_SPEED
	movwf SENSOR_89_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_89_PWM_VOLUME
	subwf SENSOR_89_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade89		; Target = volume

	btfss STATUS, C
	goto fadedown89

	incf SENSOR_89_PWM_VOLUME, f		; fade up!
	goto dontdofade89
fadedown89:
	decf SENSOR_89_PWM_VOLUME, f		; fade down!
	goto dontdofade89
updateImmediately89:
	movfw SENSOR_89_PWM_TARGET
	movwf SENSOR_89_PWM_VOLUME

dontdofade89:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_89_ROLLING_TIMER_LOW
	subwf SENSOR_89_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit89

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_89_PORT, SENSOR_89_PIN
	goto retnow89

overlimit89:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_89_PORT, SENSOR_89_PIN

retnow89:

	#endif
#endif


#ifdef SENSOR_90_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_90_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_90_PORT, SENSOR_90_PIN
;	bcf SENSOR_90_PORT, SENSOR_90_PIN
;retnow90:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_90_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade90	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_90_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately90

dofade90:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_90_ROLLING_TIMER_HIGH, f
	goto dontdofade90

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_90_PWM_SPEED
	movwf SENSOR_90_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_90_PWM_VOLUME
	subwf SENSOR_90_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade90		; Target = volume

	btfss STATUS, C
	goto fadedown90

	incf SENSOR_90_PWM_VOLUME, f		; fade up!
	goto dontdofade90
fadedown90:
	decf SENSOR_90_PWM_VOLUME, f		; fade down!
	goto dontdofade90
updateImmediately90:
	movfw SENSOR_90_PWM_TARGET
	movwf SENSOR_90_PWM_VOLUME

dontdofade90:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_90_ROLLING_TIMER_LOW
	subwf SENSOR_90_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit90

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_90_PORT, SENSOR_90_PIN
	goto retnow90

overlimit90:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_90_PORT, SENSOR_90_PIN

retnow90:

	#endif
#endif


#ifdef SENSOR_91_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_91_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_91_PORT, SENSOR_91_PIN
;	bcf SENSOR_91_PORT, SENSOR_91_PIN
;retnow91:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_91_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade91	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_91_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately91

dofade91:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_91_ROLLING_TIMER_HIGH, f
	goto dontdofade91

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_91_PWM_SPEED
	movwf SENSOR_91_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_91_PWM_VOLUME
	subwf SENSOR_91_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade91		; Target = volume

	btfss STATUS, C
	goto fadedown91

	incf SENSOR_91_PWM_VOLUME, f		; fade up!
	goto dontdofade91
fadedown91:
	decf SENSOR_91_PWM_VOLUME, f		; fade down!
	goto dontdofade91
updateImmediately91:
	movfw SENSOR_91_PWM_TARGET
	movwf SENSOR_91_PWM_VOLUME

dontdofade91:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_91_ROLLING_TIMER_LOW
	subwf SENSOR_91_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit91

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_91_PORT, SENSOR_91_PIN
	goto retnow91

overlimit91:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_91_PORT, SENSOR_91_PIN

retnow91:

	#endif
#endif


#ifdef SENSOR_92_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_92_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_92_PORT, SENSOR_92_PIN
;	bcf SENSOR_92_PORT, SENSOR_92_PIN
;retnow92:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_92_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade92	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_92_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately92

dofade92:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_92_ROLLING_TIMER_HIGH, f
	goto dontdofade92

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_92_PWM_SPEED
	movwf SENSOR_92_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_92_PWM_VOLUME
	subwf SENSOR_92_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade92		; Target = volume

	btfss STATUS, C
	goto fadedown92

	incf SENSOR_92_PWM_VOLUME, f		; fade up!
	goto dontdofade92
fadedown92:
	decf SENSOR_92_PWM_VOLUME, f		; fade down!
	goto dontdofade92
updateImmediately92:
	movfw SENSOR_92_PWM_TARGET
	movwf SENSOR_92_PWM_VOLUME

dontdofade92:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_92_ROLLING_TIMER_LOW
	subwf SENSOR_92_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit92

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_92_PORT, SENSOR_92_PIN
	goto retnow92

overlimit92:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_92_PORT, SENSOR_92_PIN

retnow92:

	#endif
#endif


#ifdef SENSOR_93_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_93_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_93_PORT, SENSOR_93_PIN
;	bcf SENSOR_93_PORT, SENSOR_93_PIN
;retnow93:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_93_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade93	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_93_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately93

dofade93:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_93_ROLLING_TIMER_HIGH, f
	goto dontdofade93

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_93_PWM_SPEED
	movwf SENSOR_93_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_93_PWM_VOLUME
	subwf SENSOR_93_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade93		; Target = volume

	btfss STATUS, C
	goto fadedown93

	incf SENSOR_93_PWM_VOLUME, f		; fade up!
	goto dontdofade93
fadedown93:
	decf SENSOR_93_PWM_VOLUME, f		; fade down!
	goto dontdofade93
updateImmediately93:
	movfw SENSOR_93_PWM_TARGET
	movwf SENSOR_93_PWM_VOLUME

dontdofade93:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_93_ROLLING_TIMER_LOW
	subwf SENSOR_93_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit93

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_93_PORT, SENSOR_93_PIN
	goto retnow93

overlimit93:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_93_PORT, SENSOR_93_PIN

retnow93:

	#endif
#endif


#ifdef SENSOR_94_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_94_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_94_PORT, SENSOR_94_PIN
;	bcf SENSOR_94_PORT, SENSOR_94_PIN
;retnow94:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_94_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade94	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_94_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately94

dofade94:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_94_ROLLING_TIMER_HIGH, f
	goto dontdofade94

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_94_PWM_SPEED
	movwf SENSOR_94_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_94_PWM_VOLUME
	subwf SENSOR_94_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade94		; Target = volume

	btfss STATUS, C
	goto fadedown94

	incf SENSOR_94_PWM_VOLUME, f		; fade up!
	goto dontdofade94
fadedown94:
	decf SENSOR_94_PWM_VOLUME, f		; fade down!
	goto dontdofade94
updateImmediately94:
	movfw SENSOR_94_PWM_TARGET
	movwf SENSOR_94_PWM_VOLUME

dontdofade94:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_94_ROLLING_TIMER_LOW
	subwf SENSOR_94_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit94

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_94_PORT, SENSOR_94_PIN
	goto retnow94

overlimit94:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_94_PORT, SENSOR_94_PIN

retnow94:

	#endif
#endif


#ifdef SENSOR_95_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_95_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_95_PORT, SENSOR_95_PIN
;	bcf SENSOR_95_PORT, SENSOR_95_PIN
;retnow95:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_95_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade95	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_95_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately95

dofade95:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_95_ROLLING_TIMER_HIGH, f
	goto dontdofade95

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_95_PWM_SPEED
	movwf SENSOR_95_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_95_PWM_VOLUME
	subwf SENSOR_95_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade95		; Target = volume

	btfss STATUS, C
	goto fadedown95

	incf SENSOR_95_PWM_VOLUME, f		; fade up!
	goto dontdofade95
fadedown95:
	decf SENSOR_95_PWM_VOLUME, f		; fade down!
	goto dontdofade95
updateImmediately95:
	movfw SENSOR_95_PWM_TARGET
	movwf SENSOR_95_PWM_VOLUME

dontdofade95:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_95_ROLLING_TIMER_LOW
	subwf SENSOR_95_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit95

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_95_PORT, SENSOR_95_PIN
	goto retnow95

overlimit95:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_95_PORT, SENSOR_95_PIN

retnow95:

	#endif
#endif


#ifdef SENSOR_96_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_96_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_96_PORT, SENSOR_96_PIN
;	bcf SENSOR_96_PORT, SENSOR_96_PIN
;retnow96:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_96_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade96	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_96_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately96

dofade96:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_96_ROLLING_TIMER_HIGH, f
	goto dontdofade96

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_96_PWM_SPEED
	movwf SENSOR_96_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_96_PWM_VOLUME
	subwf SENSOR_96_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade96		; Target = volume

	btfss STATUS, C
	goto fadedown96

	incf SENSOR_96_PWM_VOLUME, f		; fade up!
	goto dontdofade96
fadedown96:
	decf SENSOR_96_PWM_VOLUME, f		; fade down!
	goto dontdofade96
updateImmediately96:
	movfw SENSOR_96_PWM_TARGET
	movwf SENSOR_96_PWM_VOLUME

dontdofade96:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_96_ROLLING_TIMER_LOW
	subwf SENSOR_96_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit96

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_96_PORT, SENSOR_96_PIN
	goto retnow96

overlimit96:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_96_PORT, SENSOR_96_PIN

retnow96:

	#endif
#endif


#ifdef SENSOR_97_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_97_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_97_PORT, SENSOR_97_PIN
;	bcf SENSOR_97_PORT, SENSOR_97_PIN
;retnow97:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_97_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade97	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_97_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately97

dofade97:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_97_ROLLING_TIMER_HIGH, f
	goto dontdofade97

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_97_PWM_SPEED
	movwf SENSOR_97_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_97_PWM_VOLUME
	subwf SENSOR_97_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade97		; Target = volume

	btfss STATUS, C
	goto fadedown97

	incf SENSOR_97_PWM_VOLUME, f		; fade up!
	goto dontdofade97
fadedown97:
	decf SENSOR_97_PWM_VOLUME, f		; fade down!
	goto dontdofade97
updateImmediately97:
	movfw SENSOR_97_PWM_TARGET
	movwf SENSOR_97_PWM_VOLUME

dontdofade97:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_97_ROLLING_TIMER_LOW
	subwf SENSOR_97_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit97

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_97_PORT, SENSOR_97_PIN
	goto retnow97

overlimit97:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_97_PORT, SENSOR_97_PIN

retnow97:

	#endif
#endif


#ifdef SENSOR_98_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_98_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_98_PORT, SENSOR_98_PIN
;	bcf SENSOR_98_PORT, SENSOR_98_PIN
;retnow98:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_98_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade98	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_98_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately98

dofade98:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_98_ROLLING_TIMER_HIGH, f
	goto dontdofade98

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_98_PWM_SPEED
	movwf SENSOR_98_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_98_PWM_VOLUME
	subwf SENSOR_98_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade98		; Target = volume

	btfss STATUS, C
	goto fadedown98

	incf SENSOR_98_PWM_VOLUME, f		; fade up!
	goto dontdofade98
fadedown98:
	decf SENSOR_98_PWM_VOLUME, f		; fade down!
	goto dontdofade98
updateImmediately98:
	movfw SENSOR_98_PWM_TARGET
	movwf SENSOR_98_PWM_VOLUME

dontdofade98:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_98_ROLLING_TIMER_LOW
	subwf SENSOR_98_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit98

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_98_PORT, SENSOR_98_PIN
	goto retnow98

overlimit98:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_98_PORT, SENSOR_98_PIN

retnow98:

	#endif
#endif


#ifdef SENSOR_99_PRESENT
	#if (SENSOR_ID_PWM_LED == SENSOR_99_TYPE)


;	; omg hax
;	bcf STATUS, RP0 ; bank 0
;	bsf SENSOR_99_PORT, SENSOR_99_PIN
;	bcf SENSOR_99_PORT, SENSOR_99_PIN
;retnow99:

	bsf STATUS, RP0 ; bank 1

	; Inc timer_low. this is the value which is used to toggle the
	; output HIGH or LOW
	movlw 0x0A
	addwf SENSOR_99_ROLLING_TIMER_LOW, f
	btfss STATUS, C
	goto dontdofade99	; Only proceed in fading the LED towards
												; TARGET if this is at 0, to give some delay.
												; Alternatively, if PWM_SPEED is zero, just go there immediately.
	movf SENSOR_99_PWM_SPEED, f
	btfsc STATUS, Z
	goto updateImmediately99

dofade99:
	; update our rolling timer. is it time to fade slightly?
	decfsz SENSOR_99_ROLLING_TIMER_HIGH, f
	goto dontdofade99

	; Yup, time to fade. Reset the high portion of the rolling
	; timer first..
	movfw SENSOR_99_PWM_SPEED
	movwf SENSOR_99_ROLLING_TIMER_HIGH

	; and then fade towards the target.
	movfw SENSOR_99_PWM_VOLUME
	subwf SENSOR_99_PWM_TARGET, w
	btfsc STATUS, Z
	goto dontdofade99		; Target = volume

	btfss STATUS, C
	goto fadedown99

	incf SENSOR_99_PWM_VOLUME, f		; fade up!
	goto dontdofade99
fadedown99:
	decf SENSOR_99_PWM_VOLUME, f		; fade down!
	goto dontdofade99
updateImmediately99:
	movfw SENSOR_99_PWM_TARGET
	movwf SENSOR_99_PWM_VOLUME

dontdofade99:
	; perform PWM according to the value of TIMER_LOW.
	movfw SENSOR_99_ROLLING_TIMER_LOW
	subwf SENSOR_99_PWM_VOLUME, w
	btfss STATUS, C
	goto overlimit99

	bcf STATUS, RP0 ; bank 0
	bsf SENSOR_99_PORT, SENSOR_99_PIN
	goto retnow99

overlimit99:
	nop		; This is here to preserve timing. Because the above btfss causes a pipeline stall,
	nop  	; we slow down the non-stalled branch with a couple nops.

	bcf STATUS, RP0 ; bank 0
	bcf SENSOR_99_PORT, SENSOR_99_PIN

retnow99:

	#endif
#endif

	bcf STATUS, RP0 ; bank 0

	goto endpwmsensors

	end